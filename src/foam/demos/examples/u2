
## U3
##  Background
U3 is FOAM's native UI library.
It is named U3 because it is FOAM's third UI library.
The first UI library was template based and U2, FOAM's second UI library, was based on an Internal Domain Specific Language (IDSL) or Embedded Domain Specific Language (EDSL).
This IDSL is used to describe virtual DOM structures.
DOM is the browser's native API for manipulating the page contents, and stands for Document Object Model.
A Virtual-DOM is an API which mirrors the real DOM API but does so in JS.
U3 is a simplification of U2.
<br>
The advantages of a Virtual-DOM are:
<ol>
<li>It is more secure because, unlike template-based approaches, it isn't prone to Cross-Site-Scripting (XSS) attacks.</li>
<li>It can offer higher-level features and abstracts over browser incompatibilities.</li>
<li>It doesn't require a template parser, which can either make builds faster or the download size smaller, depending on where the template parsing is performed.</li>
<li>It offers higher-level features which enable you to perform some functions with less code.</li>
</oll>
Improved security was the primary motivation for U2.
Simplified use over U2, without losing any of U2's security benefits, was the primary motivation for U3.

All 32 components extend foam.u2.Element, which loosely modelled after the DOM <a href="https://www.w3schools.com/jsref/dom_obj_all.asp">Element<a> class.
--
add('testing');

##   Virtual vs. Real DOM
--
console.profile('p1');
function test1() {
var startTime = performance.now();
var node = foam.u2.Element.create({nodeName: 'UL'});     // Create a <ul> node
for ( var i = 0 ; i < 100 ; i++ )
  node.start('li').add("text" + i).end();                // Append an <li>

//add(node);
log(performance.now() - startTime);
}
test1();

function test2() {
var startTime = performance.now();
var node = document.createElement("UL");               // Create a <ul> node
for ( var i = 0 ; i < 100 ; i++ ) {
  var li = document.createElement("LI")
  li.appendChild(document.createTextNode("text" + i)); // Append an <li>
  node.appendChild(li);
}
//el().appendChild(node);
log(performance.now() - startTime);
}
test2()
console.profileEnd('p1');


##   DSL
##   Intro1
##   Intro2
##    SubIntro
##   Hello World!
Let's use U3 to say hello
--
add(foam.u2.Element.create().add('Hello World!'));
##   nodeName
If you inspect the HTML output from the Hellow World! example, you'll notice that it is a div tag.<br>
However, if you want to change it to another type, you can specify the node's name with the nodeName property.
--
add(foam.u2.Element.create({nodeName: 'b'}).add('Hello World!'));
##  Short Form
Given it is so common to want to create new Elements from within other Elements, Element has a method called start()
which is used to add another Element to it.
--
start('b').add('Hello again!').end();
##  Tag
In the above example we wanted to add text inside of the <b> tag, so we started with start() and then called add() before end()-ing the tag.
But if you didn't need to add() anything inside the tag, you could just use the tag() method. The next two lines are equivalent:
--
start('input').end();
tag('input');
##   v2
##   ControllerMode
##   DisplayMode
##   Borders
--
foam.CLASS({
  name: 'CardBorder',
  extends: 'foam.u2.Element',
  css: `
    ^ {
      background: white;
      border-radius: 3px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.38);
      margin: 8px;
      transform-origin: top left;
      display: inline-block;
    }
    ^content { padding: 6px; width: 300px; height: 200px; background: white; }
  `,
  methods: [
    function render() {
      this.
        addClass().
        start('div', null, this.content$).
          addClass(this.myClass('content')).
        end();
    }
  ]
});

add(CardBorder.create().add('content').tag('br').add('more content').tag('br').add('even more content'));

##    content
##   ViewSpec
##   Tooltips
##   shown / show() / hide()
##   focused / focus() / blur()
##   Creating a Component
##    render()
##   Keyboard Shortcuts
##   el()
##   id
##   E()
##   Children
##    start() / end()
##    br()
br() is just short form for tag('br'), the html line-break element.
##    nbsp()
no-breaking space, the same as adding &nbsp; to your html
##    remove()
##    add()
##     adding properties
##     toE()
##     view:
##    removeAllChildren()
##    setChildren()
##   Styling
##    style()
--
start().style({background: 'pink', border: '2px solid black;'}).add('styled content').end()
##    css:
##    CSS Variables
##    inheritCSS
##   CSS Classes
##    addClass() / addClasses()
##    enableClass()
##    myClass()
--
foam.CLASS({
  package: 'some.good.package',
  name: 'Test',
  extends: 'foam.u2.Element',
  css: `
    ^ { background: pink; }
    ^subsection { background: green; }
  `,
  classes: [
    {
       name: 'SubTest',
       extends: 'foam.u2.Element',
       css: `
         ^ { background: pink; }
       `,
       methods: [
         function render() {
           this.SUPER();
            this.
              addClass(this.myClass()).
              add(this.myClass());
         }
       ]
    }
  ],
  methods: [
    function render() {
      this.SUPER();
      this.
        addClass(this.myClass()).
        add(this.myClass()).
        start().
          addClass(this.myClass('subsection')).
          add(this.myClass('subsection')).
        end();
      this.add(this.SubTest.create({}, this));
    }
  ]
});
add(some.good.package.Test.create());
##    removeClass()
##   Attributes
##    attr() & setAttribute()
attr() and setAttribute() are the same, with setAttribute() being for DOM compatibility.
--
start('img').attr('src', '/foam3/src/foam/u2/images/foam_red.png').end();
start('img').setAttribute('src', '/foam3/src/foam/u2/images/foam_red.png').end();
##    attrs()
--
start('img').attrs({
  src: '/foam3/src/foam/u2/images/foam_red.png',
  alt: 'foam logo',
  height: 100
}).end();
##    removeAttribute()
--
##   Control Flow
##    repeat()
--
start('ul').repeat(1, 10, function(i) { this.start('li').add(i).end(); }).end();

##    call()
--
start()
  .call(function() { this.add('call'); })
.end();

##    callIf
--
start()
  .callIf(true,  function() { this.add('true'); })
  .br()
  .callIf(false, function() { this.add('false'); })
.end();

##    callIfElse
--
start()
  .callIfElse(true,  function() { this.add('true'); }, function() { this.add('false'); })
  .br()
  .callIfElse(false, function() { this.add('false'); }, function() { this.add('false'); })
.end();

##    forEach()
--
start('ul').forEach(['Apples', 'Bananas', 'Oranges'], function(i) { this.start('li').add(i).end(); }).end();
##   Events
##    on() & addEventListener
on() and onEventListener() are the same, with onEventListener() being for DOM compatibility.
--
start('a').add('click me').on('click', function() { window.alert('clicked'); }).end();
##    removeEventListener()
##    onKey
##    DAOs
Let's create a DAO with some sample data to work with:
--
foam.CLASS({
  name: 'DAOSampleData',
  properties: [
    { class: 'Int', name: 'id' }, 'name', 'value'
  ],
  methods: [
    function toSummary() { return this.id + ' ' + this.value; }
  ]
});

var dao = foam.dao.EasyDAO.create({
  of: DAOSampleData,
  daoType: 'MDAO',
  testData: [
    { id: 1, name: 'John',  value: 'value1' },
    { id: 2, name: 'John',  value: 'value2' },
    { id: 3, name: 'Kevin', value: 'value3' },
    { id: 4, name: 'Kevin', value: 'value4' },
    { id: 5, name: 'Larry', value: 'value5' },
    { id: 6, name: 'Linda', value: 'value6' }
  ]
});

// Now, to add the data to our view, we can just call dao.select():
add('Example 1');
start('ul').call(function() {
  dao.select(d => {
    this.start('li').add(d.id, ' ', d.name, ' ', d.value).end();
  });
});

// That works great, but has one limitation: it's static. If the data in the DAO
// updates, the view won't, it will just remain the same forever. Sometimes, that's
// what you want, but if you wanted the view to update whenever the DAO updated,
// then instead call the Element.select() method:

add('Example 2');
start('ul')
  .select(dao, function(d) {
    this.start('li').add(d.id, ' ', d.name, ' ', d.value).end();
  })
.end();

// Now, if we add more data in the future, notice that only the second list
// updates:

dao.put(DAOSampleData.create({id: 999, name: 'Superman', value: 'Hero'}));

start('a').add('click to add more data').on('click', function() {
  for ( let i = 0 ; i < 10 ; i++ ) {
    window.setTimeout(() => {
      var j = Math.floor(Math.random() * 1000);
      var d = DAOSampleData.create({id: j, name: 'Mr. ' + j, value: 'value ' + j});
      dao.put(d);
    }, 250 * i);
  }
}).end();

##    select()
##   startContext() / endContext()
##   i18n
##    Messages
##    translate()
The easiest way is in your view which adds the data to the GUI, instead
of calling .add(), you call .translate() instead.
The first argument of translate() is a suitable translation key, and the
second argument is the default English value that you would have add()'ed.
--

foam.CLASS({
  name: 'SampleTranslationData',
  properties: [
    'id', 'label'
  ]
});

var dao = foam.dao.EasyDAO.create({
  of: SampleTranslationData,
  daoType: 'MDAO',
  testData: [
    { id: 'key1', label: 'label1' },
    { id: 'key2', label: 'label2' },
    { id: 'key3', label: 'label3' }
  ]
});

// Gives untranslated values:
add(E().select(dao, function(d) {
  return this.E().add(d.id, ' ', d.label);
}));

add(E('hr'));

// create a simple mock translationService
var mockTranslationService = {
  getTranslation: function(_, _, def) { return def + ' en fran√ßais'; }
};

// Gives translated values:
add(E().startContext({translationService: mockTranslationService}).select(dao, function(d) {
  return this.E().add(d.id, ' ').translate('SampleTranslationData.' + d.id + '.label', d.label);
}));

##   write()
The Element.write() method appends to Element to the end of the document body.
This is typically only used for debugging purposes, not in production code.
--
foam.u2.Element.create().start().add('Here I am, way at the bottom of the page!').end().write();

##   Tags
##    attributes
##    registerElement
##    elementForName
##   View
##    fromProperty()
##   Controller
##   Views
##    ActionView
##   StackView
##   More
