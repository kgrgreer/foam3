## Introduction

##  Lib

##  Models

##   Properties

##   Methods

##   Actions

##   Listeners

##   Constants

##   Messages

##   Topics

##   Imports / Exports

##   Requires

##   Implements

##   Topics

##   Requires

##   Extends

##  FObjects

##   equals

##   compareTo

##   diff

##   hashCode

##   clone

##   shallowClone

##   copyFrom

##   toSummary

##   dot

##   slot

##  Classes

##  Slots

## DAOs

## FOAM By Example
##  Test Class
Define a new class with foam.CLASS
--
foam.CLASS({
  name: 'Test',
  properties: [
    // short-form
    'a',
    // long-form
    {
      name: 'b'
    }
  ],
  methods: [
    // short-form
    function f1() { return 1; },
    // long-form
    {
      name: 'f2',
      code: function() { return 2; }
    }
  ]
});


##  Test describe
Use class.describe() to learn about the class
--
Test.describe();


##  Test create
Create an instance of Test
--
var o = Test.create();
log("Class: ", o);
log('a: ' + o.a + ', b: ' + o.b);


##  Test create with values
Create an instance with a map argument to initialize properties
--
var o = Test.create({ a: 3, b: 'hello' });
log("Class: ", o);
log('a: ' + o.a + ', b: ' + o.b);


##  Class reference
Objects have a reference to their class in .cls_
--
var o = Test.create({ a: 3, b: 'hello' });
log("Class object:", o.cls_);


##  Test isInstance
Test Class membership with Class.isInstance()
--
var o = Test.create({ a: 3, b: 'hello' });
log('Test.isInstance(o)?', Test.isInstance(o));
log('Test.isInstance("foo")?', Test.isInstance("Test"));


##  Test Methods
Call Methods on the Test instance
--
var o = Test.create({ a: 3, b: 'hello' });
log("Methods return: ", o.f1(), o.f2());


##  Update Properties
Properties accept value changes as normal
--
var o = Test.create({ a: 3, b: 'hello' });
o.a++;
o.b = 'bye';
log('New values: a: ' + o.a + ', b: ' + o.b);


##  Test copyFrom
Multiple properties can be updated at once using copyFrom()
--
var o = Test.create({ a: 3, b: 'hello' });
o.copyFrom({a: 42, b: 'rosebud'});
log('New values: a: ' + o.a + ', b: ' + o.b);


##  Test toString
Call toString on an object
--
var o = Test.create({ a: 3, b: 'hello' });
log("toString:", o.toString());


##  Describe instance
Call describe() on an object to see its Property values
--
var o = Test.create({ a: 3, b: 'hello' });
o.describe();


##  Properties and Methods are types of Axioms
Get an array of all Axioms belonging to a Class by calling getAxioms
--
Test.getAxioms().forEach(function(a) {
  log(a.cls_ && a.cls_.name, a.name);
});


##  Test getAxiomByName
Find an Axiom for a class using getAxiomByName
--
var a = Test.getAxiomByName('a');
log(a.cls_.name, a.name);


##  Test getAxiomsByClass
Find all Axioms of a particular class using getAxiomsByClass
--
Test.getAxiomsByClass(foam.core.Method).forEach(function(a) {
  log(a.cls_ && a.cls_.name, a.name);
});


##  Test Property constants
Properties are defined on the class as constants
--
log("Method CODE property constant:", foam.core.Method.CODE);
foam.core.Method.CODE.describe();


##  Property mapping
Property constants contain map functions
--
// foam.core.Method.NAME.f(obj) returns obj.name
log("Method names in Test:",
  Test
    .getAxiomsByClass(foam.core.Method)
    .map(foam.core.Method.NAME.f)
    .join(', ')
);


##  Property comparators
Property constants contain comparators
--
// foam.core.Method.NAME.compare is a compare function
// that properly compares values of NAME.
log("Method names in Test, sorted:",
  Test
    .getAxiomsByClass(foam.core.Method)
    .sort(foam.core.Method.NAME.compare)
    .map(foam.core.Method.NAME.f)
    .join(', ')
);


##  Test init
If a Class defineds an init() method, it's called when an object is created.
--
foam.CLASS({
  name: 'InitTest',
  properties: [ 'a' ],
  methods: [ function init() { this.a = 'just born!'; } ]
});
var o = InitTest.create();
log("Initialized value:", o.a);


##  Create default values
Default Values can be defined for Properties
--
foam.CLASS({
  name: 'DefaultValueTest',
  properties: [
    { name: 'a', value: 42 },
    { name: 'b', value: 'foo' },
    { name: 'c' }
  ]
});
var o = DefaultValueTest.create();
log("Values:", o.a, o.b, o.c);


##  Test hasOwnProperty
FObject.hasOwnProperty() tells you if a Property has been set
--
log("Before setting:", o.hasOwnProperty('a'), o.hasOwnProperty('b'), o.hasOwnProperty('c'));
o.a = 99;
o.c = 'test';
log("After setting a, c:", o.hasOwnProperty('a'), o.hasOwnProperty('b'), o.hasOwnProperty('c'));


##  Test clearProperty
FObject.clearProperty() reverts a value back to its value
--
log("Before clearing:", o.hasOwnProperty('a'), o.a);
o.clearProperty('a');
log("After clearing:", o.hasOwnProperty('a'), o.a);


##  Create factory test
Properties can have factory methods which create their initial value when they are first accessed.
--
var factoryCount = 0;
foam.CLASS({
  name: 'FactoryTest',
  properties: [
    {
      name: 'a',
      factory: function() { factoryCount++; return 42; }
    }
  ]
});
var o = FactoryTest.create();


##  Test factory running
Factories run once when the property is first accessed
--
log("Before:    factory run count:", factoryCount);
log("Value:", o.a, " factory run count:", factoryCount);
// Factory not called value accessed second time:
log("Again:", o.a, " factory run count:", factoryCount);


##  Test factory not run
Factories do not run if the value is set before being accessed
--
// Value supplied in create()
o = FactoryTest.create({a: 42});
log("Value:", o.a, " factory run count:", factoryCount);

// Value set before first access
o = FactoryTest.create();
o.a = 99;
log("Value:", o.a, " factory run count:", factoryCount);


##  FactoryTest
Factory is called again if clearProperty() called
--
var o = FactoryTest.create();
log("Run factory: ", o.a);
log(" factory run count:", factoryCount);
o.clearProperty('a');
log("Again:       ", o.a);
log(" factory run count:", factoryCount);


##  Property Getters and Setters
Properties can define their own getter and setter functions
--
foam.CLASS({
  name: 'GetterSetter',
  properties: [
    'radius',
    {
      name: 'diameter',
      getter: function() {
        return this.radius * 2;
      },
      setter: function(diameter) {
        this.radius = diameter / 2;
      }
    }
  ]
});
var o = GetterSetter.create();

o.diameter = 10;
log("r:", o.radius, "d:", o.diameter);

o.radius = 10;
log("r:", o.radius, "d:", o.diameter);



##  Property Adapt
The adapt function is called on a property value update
--
// Properties can specify an 'adapt' function which is called whenever
// the properties' value is updated. It's the adapt function's responsibility
// to convert or coerce the type if necessary.

// Both the previous value of the property and the proposed new value are
// passed to adapt.  Adapt returns the desired new value, which may be different
// from the newValue it's provided.
foam.CLASS({
  name: 'AdaptTest',
  properties: [
    {
      name: 'flag',
      adapt: function(oldValue, newValue) {
        log('Adapt old:', oldValue, "to new:", newValue);
        // adapt to a boolean
        return !! newValue;
      }
    }
  ]
});
// adapt called once from the flag:true initializer here
var o = AdaptTest.create({ flag: true });

// adapt called again to adapt null
o.flag = null;
log("Adapted value:", o.flag);


##  Property preSet
The preSet function is called on a property update, after adapt
--
// Properties can specify a 'preSet' function which is called whenever
// the properties' value is updated, just after 'adapt', if present.

// Both the previous value of the property and the proposed new value are
// passed to preSet.  PreSet returns the desired new value, which may be different
// from the newValue it's provided.
foam.CLASS({
  name: 'PreSetTest',
  properties: [
    {
      name: 'a',
      preSet: function(oldValue, newValue) {
        log('preSet p1');
        return newValue + "y";
      }
    }
  ]
});
var o = PreSetTest.create({ a: 'Smith' });
log(o.a);

o.a = 'Jones';
log(o.a);


##  Property postSet
The postSet function is called after a property update
--
// Properties can specify a 'postSet' function which is called after
// the properties' value is updated.  PostSet has no return value and
// cannot stop the newValue from taking effect, since postSet it is
// called after the value has been set.
var lastPostSetValue;
foam.CLASS({
  name: 'PostSetTest',
  properties: [
    {
      name: 'a',
      postSet: function(oldValue, newValue) {
        log('postSet old:', oldValue, "new:", newValue);
        // this.a will match the newValue, since the set is already
        // complete
        lastPostSetValue = this.a;
      }
    }
  ]
});
var o = PostSetTest.create({ a: 'Smith' });
o.a = 'Jones';
o.a = 'Green';


##  Property adapt pre post
Properties can define adapt, preSet, and postSet all at once
--
var lastPostSetValue;
foam.CLASS({
  name: 'AdaptPrePostTest',
  properties: [
    {
      name: 'a',
      adapt: function(oldValue, newValue) {
        log('adapt old:', oldValue, 'new:', newValue);
        return newValue + 1;
      },
      preSet: function(oldValue, newValue) {
        log('preSet old:', oldValue, 'new:', newValue);
        return newValue + 2;
      },
      postSet: function(oldValue, newValue) {
        log('postSet old:', oldValue, 'new:', newValue);
        lastPostSetValue = this.a;
      }
    }
  ]
});
var o = AdaptPrePostTest.create();
o.a = 1;
o.a = 10;


##  Create constant test
Classes can define Constants
--
foam.CLASS({
  name: 'ConstantTest',
  constants: {
    MEANING_OF_LIFE: 42,
    FAVOURITE_COLOR: 'green'
  }
});
var o = ConstantTest.create();
log("Constant values:", o.MEANING_OF_LIFE, o.FAVOURITE_COLOR);


##  Constants Class access
Constants can also be accessed from the Class
--
log("ConstantTest constants:", ConstantTest.MEANING_OF_LIFE, ConstantTest.FAVOURITE_COLOR);
log("o.cls_ constants:", o.cls_.MEANING_OF_LIFE, o.cls_.FAVOURITE_COLOR);


##  Constants are constant
Constants are constant, and cannot be assigned
--
o.MEANING_OF_LIFE = 43;
log("Constant after setting to 43:", o.MEANING_OF_LIFE);


##  Person Class
A basic Person class
--
// Methods in subclasses can override methods from ancestor classes, as is
// done below with toString().  Employee.toString() calls its parent classes
// toString() method by calling 'this.SUPER()'.
foam.CLASS({
  name: 'Person',
  properties: [ 'name', 'sex' ],
  methods: [
    function toString() { return this.name + ' ' + this.sex; }
  ]
});


##  Create Person and Employee
Classes can be subclassed with extends
--
// Methods in subclasses can override methods from ancestor classes, as is
// done below with toString().  Employee.toString() calls its parent classes
// toString() method by calling 'this.SUPER()'.
foam.CLASS({
  name: 'Employee',
  extends: 'Person',
  properties: [ 'salary' ],
  methods: [
    function toString() { return this.SUPER() + ' ' + this.salary; }
  ]
});

var p = Person.create({name: 'John', sex: 'M'});
log("Person:", p.toString());

var e = Employee.create({name: 'Jane', sex: 'F', salary: 50000});
log("Employee:", e.toString());


##  Test SubClass
Test if one class is a sub-class of another
--
log("Is Employee a subclass of Person?", Person.isSubClass(Employee));
log("Is Person a subclass of Employee?", Employee.isSubClass(Person));


##  Test SubClass self
A Class is considered a sub-class of itself
--
log("Is Person a subclass of Person?", Person.isSubClass(Person));


##  Test FObject SubClass
FObject is the root class of all other classes
--
log("Is Employee an FObject?", foam.core.FObject.isSubClass(Employee));
log("Is Person an FObject?", foam.core.FObject.isSubClass(Person));


##  Test isSubClass and package
isSubClass() isn't confused by classes with the same name in different packages
--
foam.CLASS({
  package: 'com.acme.package',
  name: 'Person'
});
// The two Person classes are independent of each other
log("Is Person a packaged-Person?", com.acme.package.Person.isSubClass(Person));
log("Is packaged-Person a Person?", Person.isSubClass(com.acme.package.Person));

##  Interface inheritance of Properties
--
foam.INTERFACE({
  name: 'II1',
  properties: [
    'id', 'firstName', 'lastName'
  ]
});
foam.CLASS({
  name: 'IC1',
  implements: [ 'II1' ]
});

var c1 = IC1.create({id: 1, firstName: 'John'});
log(c1.stringify());

##  Test isSubClass and interfaces
isSubClass() works for interfaces
--
foam.CLASS({
  package: 'test',
  name: 'ThingI',
  methods: [ function foo() { log('Called ThingI.foo()'); } ]
});
foam.CLASS({
  package: 'test',
  name: 'C1',
  implements: [ 'test.ThingI' ]
});
log("Is C1 a ThingI?", test.ThingI.isSubClass(test.C1));


##  Test isSubClass sub interfaces
isSubClass() works for sub-interfaces
--
foam.CLASS({
  package: 'test',
  name: 'Thing2I',
  implements: [ 'test.ThingI' ]
});
foam.CLASS({
  package: 'test',
  name: 'Thing3I',
  implements: [ 'test.ThingI' ]
});
foam.CLASS({
  package: 'test',
  name: 'C2',
  implements: [ 'test.Thing2I' ]
});
var o = test.C2.create();
o.foo();

log("Is C2 a ThingI?", test.ThingI.isSubClass(test.C2));
log("Is C2 a Thing2I?", test.Thing2I.isSubClass(test.C2));
log("Is C2 a Thing3I?", test.Thing3I.isSubClass(test.C2));


##  Test isInstance sub interfaces
isInstance() works for sub-interfaces
--
log("Is o a ThingI?", test.ThingI.isInstance(o));
log("Is o a Thing2I?", test.Thing2I.isInstance(o));
log("Is o a Thing3I?", test.Thing3I.isInstance(o));
log("Is o a C2?", test.C2.isInstance(o));


##  Package imports exports demo
Package and imports/exports demo
--
foam.CLASS({
  package: 'demo.bank',
  name: 'Account',
  imports: [ 'reportDeposit' ],
  properties: [
    { name: 'id'      },
    { name: 'status'  },
    { name: 'balance', value: 0 }
  ],
  methods: [
    {
      name: "setStatus",
      code: function (status) {
        this.status = status;
      }
    },
    {
      name: "deposit",
      code: function (amount) {
        this.balance += amount;
        this.reportDeposit(this.id, amount, this.balance);
        log('Bank: ', this.__context__.Bank);
        return this.balance;
      }
    },
    {
      name: "withdraw",
      code: function (amount) {
        this.balance -= amount;
        return this.balance;
      }
    }
  ]
});
foam.CLASS({
  package: 'demo.bank',
  name: 'SavingsAccount',
  extends: 'demo.bank.Account',
  methods: [
    {
      name: "withdraw",
      code: function (amount) {
        // charge a fee
        this.balance -= 0.05;
        return this.SUPER(amount);
      }
    }
  ]
});
foam.CLASS({
  package: 'demo.bank',
  name: 'AccountTester',
  requires: [
    'demo.bank.Account as A',
    'demo.bank.SavingsAccount'
  ],
  imports: [ 'log as l' ],
  exports: [
    'reportDeposit',
    'as Bank' // exports 'this'
  ],
  methods: [
    function reportDeposit(id, amount, bal) {
      this.l('Deposit: ', id, amount, bal);
    },
    function test() {
      var a = this.A.create({id: 42});
      a.setStatus(true);
      a.deposit(100);
      a.withdraw(10);
      a.describe();
      var s = this.SavingsAccount.create({id: 43});
      s.setStatus(true);
      s.deposit(100);
      s.withdraw(10);
      s.describe();
    }
  ]
});
var a = demo.bank.AccountTester.create(null);
a.test();

##  Package imports exports demo
Package and imports/exports demo
--
foam.CLASS({
  name: 'A',
  methods: [ function toString() { return 'A'; } ]
});
foam.CLASS({
  name: 'B',
  methods: [ function toString() { return 'B'; } ]
});
foam.CLASS({
  name: 'C',
  requires: ['A'],
  methods: [ function toString() { return this.A.create().toString(); } ]
});

var c = C.create();
print(c.toString());

c.A = B;
print(c.toString());

c = C.create({A: B});
print(c.toString());


##  Class Refinement
Refinement upgrades the existing class rather than create a new sub-class
--
// In addition to being extended, a Class can also be refined.
// Refinement upgrades the existing class rather than create a
// new sub-class. In the following example we add 'salary' to
// the person class, rather than creating a new Employee sub-class.
foam.CLASS({
  name: 'PersonRefinement',
  refines: 'Person',
  properties: [ { class: 'Float', name: 'salary', value: 0 } ],
  methods: [
    function toString() { return this.name + ' ' + this.sex + ' ' + this.salary; }
  ]
});
var n = Person.create({name: 'Bob', sex: 'M', salary: 40000});
log("New person after refinement:", n.toString());
// The already created person, John, now has a salary too!
log("Old person after refinement:", p.toString());


##  Refine a Property
Properties in classes can be changed in a refinement
--
log("Old type of Person.salary:", Person.SALARY.cls_.name);

// Change the salary property type, add a default value
foam.CLASS({
  refines: 'Person',
  properties: [ { name: 'salary', value: 30000 } ]
});

log("New type of Person.salary:", Person.SALARY.cls_.name);

var o = Person.create({name:'John'});
log("Now with default value:", o.salary);
log("And original person gets the default too:", p.salary);


##  Cannot Refine a Property Class
Refining Properties is currently unsupported and unlikely to be supported.
--
// Refining a type of Property after classes have already been created using
// the old version will not propagate the changes to those existing classes.
foam.CLASS({ name: 'Salary', extends: 'Float' });
foam.CLASS({ name: 'Emp', properties: [ { class: 'Salary', name: 'salary' } ] });

// Since Classes are not constructed until used, we create an instance to force
// Emp to be loaded (otherwise the refinement will appear to work):
log("Emp.salary before:", Emp.create().salary);
foam.CLASS({ refines: 'Salary', properties: [ { name: 'value', value: 30000 } ]});
log("Emp.salary refined:", Emp.create().salary);


##  Refine Property
Refine foam.core.Property Class
--
// Property has special support for refinement or existing Property instances
foam.CLASS({ name: 'Emp', properties: [ { class: 'Float', name: 'salary' } ] });
Emp.create();
foam.CLASS({ refines: 'Float', properties: [ [ 'javaClass', 'Float' ] ]});
log(Emp.SALARY.javaClass);


##  Cannot Refine a SuperProperty Class
Currently unsupported and unlikely to be supported
--
foam.CLASS({ name: 'SuperClass', properties: [ 'p1' ]});
foam.CLASS({ name: 'SubClass', extends: 'SuperClass', properties: [ 'p1' ]});
log('Before: super: ', SuperClass.create().p1, 'sub: ', SubClass.create().p1);

foam.CLASS({ refines: 'SuperClass', properties: [ { name: 'p1', value: 42 } ]});
log('Refined: super: ', SuperClass.create().p1, 'sub: ', SubClass.create().p1);


##  Cannot Refine a DoubleSuperProperty Class
Currently unsupported and unlikely to be supported. Two inheritance levels.
--
foam.CLASS({ name: 'SuperClass', properties: [ 'p1' ]});
foam.CLASS({ name: 'MidClass', extends: 'SuperClass' });
foam.CLASS({ name: 'SubClass', extends: 'MidClass', properties: [ 'p1' ]});
log('Before: super: ', SuperClass.create().p1, 'mid: ', MidClass.create().p1, 'sub: ', SubClass.create().p1);

// MidClass will see the refinement since it does not redefine the p1 property, so it
// uses SuperClass' directly. SubClass keeps its own definition, and doesn't see the changes
// to SuperClass.p1
foam.CLASS({ refines: 'SuperClass', properties: [ { name: 'p1', value: 42 } ]});
log('Refined: super: ', SuperClass.create().p1, 'mid: ', MidClass.create().p1, 'sub: ', SubClass.create().p1);

##  Interface Refinement
Although rarely required, Interfaces can also be refined.
--
foam.INTERFACE({
  name: 'Somethingable',

  methods: [
    'int method1()',
    'String method2(int)'
  ]
});

log('Pre-Refinement');
Somethingable.model_.methods.forEach(m => log(m.name));

foam.INTERFACE({
  refines: 'Somethingable',
  name: 'SomethingRefinement',

  methods: [
    'int method1()', // duplicate, maybe just refining to add java type or docs
    'void method3(int, int)'
  ]
});

log('Post-Refinement');
Somethingable.model_.methods.forEach(m => log(m.name));

##  Create Listeners
Listeners are pre-bound Methods, suitable for use as callbacks (DOM, or otherwise).
--
foam.CLASS({
  name: 'ListenerTest',
  properties: [ 'name' ],
  methods: [ function m1() {
    log('m1', this.name);
    return 'M1' + this.name;
  } ],
  listeners: [ function l1() {
    log('l1', this.name);
    return 'L1' + this.name; // listener return value is ignored by most callers
  } ]
});
var o = ListenerTest.create({ name: 'Steve' });


##  Test Listeners as methods
Listeners are pre-bound Methods, suitable for use as callbacks (DOM, or otherwise).
--
// When called as methods, the same as Methods.
o.m1();
o.l1();


##  Test Listener binding
Listeners remember their self, binding "this" automatically
--
// When called as functions, the method forgets its 'self' and doesn't work,
// but the listener works.
var m = o.m1;
var l = o.l1;
m()
l();


##  Test Merged and Framed validation
It's an error to make a listener both isMerged and isFramed
--
foam.CLASS({
  name: 'MergedAndFramedTest',
  listeners: [
    {
      name: 'l',
      isMerged: true,
      isFramed: true,
      code: function() { log('listener'); }
    }
  ]
});
MergedAndFramedTest.create();


##  Test isMerged
isMerged will merge multiple events
--
c() {
      // TODO: for all async, pass things for postTestCode in promise resolve
      // If a listener has isMerged: true, it will merge multiple
      // events received withing 'mergeDelay' milliseconds into
      // a single event. 'mergeDelay' is optional and defaults to
      // 16ms.
      var mergedCalls = 0;

      foam.CLASS({
        name: 'MergedListenerTest',
        listeners: [
          {
            name: 'notMerged',
            isMerged: false, // the default
            code: function() {
              log('not merged listener');
            }
          },
          {
            name: 'merged',
            isMerged: true,
            mergeDelay: 1, // 1ms
            code: function() {
              log('merged listener ' + mergedCalls);
              mergedCalls += 1;
            }
          }
        ]
      });

      var o = MergedListenerTest.create();
      o.merged(); o.notMerged();
      o.merged(); o.notMerged();
      o.merged(); o.notMerged();
      o.merged(); o.notMerged();
      o.merged(); o.notMerged();
      o.merged(); o.notMerged();
      o.merged(); o.notMerged();

      // stop this test after one frame
      return new Promise(function(res) {
        setTimeout(res, 16);
      });


##  Framed Listener Test
isFramed will merge multiple events within an animation frame
--
c() {
      // If a listener has isFramed: true, it will merge multiple
      // events received withing one animation frame to a single
      // event delivered at the next animationFrame.
      var framedCalls = 0;
      foam.CLASS({
        name: 'FramedListenerTest',
        listeners: [
          {
            name: 'framed',
            isFramed: true,
            code: function() {
              log('framed listener ' + framedCalls);
              framedCalls += 1;
            }
          }
        ]
      });
      var o = FramedListenerTest.create();
      o.framed();
      o.framed();
      o.framed();
      o.framed();

      // delay for more than one frame to ensure the listener runs
      return new Promise(function(res) {
        setTimeout(res, 32);
      });


##  Listener delayed
Decorate a listener with delayed() to delay the execution without merging
--
c() {
      // You can decorate a listener with delayed() to delay the
      // execution of the listener. Unlike merged(), which also delays
      // results, delayed() does not merge results.
      var callOrder = '';
      var l1 = foam.__context__.delayed(function() {
        log('l1');
        callOrder += 'l1';
      }, 10);
      var l2 = foam.__context__.delayed(function() {
        log('l2');
        callOrder += 'l2';
      }, 5);
      l1();
      l2();
      l1();
      l2();

      // delay to ensure the listener runs
      return new Promise(function(res) {
        setTimeout(res, 16);
      });



##  Listener async
async(l) is the same as delayed(l, 0)
--
var callOrder = '';
var d1 = foam.__context__.async(function() {
  log('d1');
  callOrder += 'd1';
});
var d2 = function() {
  log('d2');
  callOrder += 'd2';
};
d1();
d2();
d1();
d2();

// delay to ensure the listener runs
return new Promise(function(res) {
  setTimeout(res, 16);
});


##  Listener SUPER
Listeners, like Methods, have SUPER support.
--
var alarms = '';
foam.CLASS({
  name: 'Alarm',
  listeners: [
    function alarm() { alarms += 'alarm!'; }
  ]
});
foam.CLASS({
  name: 'LongAlarm',
  extends: 'Alarm',
  listeners: [
    function alarm() {
      alarms += 'LongAlarm: ';
      this.SUPER(); this.SUPER(); this.SUPER();
    }
  ]
});
LongAlarm.create().alarm();
log(alarms);


##  Test Actions
Actions are methods which have extra information for GUIs
--
// Actions are methods which have extra information to make it easier
// to call them from GUIs. Extra information includes things like:
// a label, speech label, functions to determine if the action is currently
// available and enabled, user help text, etc.
var longCalls = 0;
foam.CLASS({
  name: 'ActionTest',
  properties: [ 'enabled', 'available' ],
  actions: [
    function shortForm() { log('short action!'); },
    {
      name: 'longForm',
      isAvailable: function() { return this.available; },
      isEnabled: function() { return this.enabled; },
      code: function() {
        log('long action!');
        longCalls += 1;
      }
    }
  ]
});
var o = ActionTest.create();
o.shortForm();

o.longForm(); // Won't be called because is not enabled or available yet
o.enabled = true;
o.longForm(); // Won't be called because is not available yet
o.available = true;
o.longForm(); // Finally able to be called


##  Interface inheritance
Interfaces copy Axioms from another class
--
// In addition to class-inheritance, FOAM also supports
// interfaces, which are a form of multiple-inheritance which
// copy Axioms from another model.
foam.CLASS({
  name: 'SampleI',
  properties: [ 't1', 't2', 't3' ],
  methods: [
    function tfoo() { log('tfoo'); },
    function tbar() { log('tbar'); }
  ]
});
foam.CLASS({
  name: 'ImplementsTest',
  implements: ['SampleI'],
  properties: [ 'p1', 'p2', 'p3' ],
  methods: [
    function foo() { log('foo'); },
    function bar() { log('bar'); }
  ]
});
var tt = ImplementsTest.create({p1:1, t1:2});
tt.tfoo(); // From SampleI
tt.foo();
log("Properties p1:", tt.p1, "t1:", tt.t1);


##  Interface multiple inheritance
Implements allows multiple inheritance, unlike extends
--
// Unlike regular inheritance with extends:, classes
// can implement: from multiple sources. However,
// implements only takes axioms from the class you reference,
// not anything it extends or implements.
foam.CLASS({
  name: 'Sample2I',
  properties: [ 'tb1', 'tb2', 'tb3' ],
  methods: [
    function tbfoo() { log('ffoo'); },
    function tbbar() { log('tbar'); }
  ]
});
foam.CLASS({
  name: 'ImplementsTest2',
  implements: ['SampleI', 'Sample2I']
});

log("ImplementsTest2 properties:",
  ImplementsTest2.getAxiomsByClass(foam.core.Property));


##  Property Inheritance
Properties in subclasses inherit from the parent's Properties
--
// FOAM also has Property-Inheritance.
// Test that a sub-class Property inherits its parent Property's class
foam.CLASS({
  name: 'PropertyInheritA',
  properties: [ {class: 'Boolean', name: 'sameName'} ]
});
foam.CLASS({
  name: 'PropertyInheritB',
  extends: 'PropertyInheritA',
  properties: [ 'sameName' ]
});
log(PropertyInheritA.SAME_NAME.cls_.id, PropertyInheritB.SAME_NAME.cls_.id);


##  Inner Classes
Inner classes are defined inside another class, not directly available in the global namespace.
--
// Classes can have inner-Classes.
var results = '';
foam.CLASS({
  name: 'InnerClassTest',
  classes: [
    { name: 'InnerClass1', properties: ['a', 'b'] },
    { name: 'InnerClass2', properties: ['x', 'y'] }
  ],
  methods: [
    function init() {
      // access from within the outer class
      var ic1 = this.InnerClass1.create({a:1, b:2});
      var ic2 = this.InnerClass2.create({x:5, y:10});
      results += ic1.a + ", " + ic1.b + ", " + ic2.x + ", " + ic2.y;
    }
  ]
});
InnerClassTest.create();
log(results);


##  Inner Class access
Inner classes are only accessible through their outer class
--
log("Access through outer:", InnerClassTest.InnerClass1.name);

// Inner-classes do not appear in the global namespace
log("Available globally?", !! globalThis.InnerClass1);


##  Inner Enums
Similar to Inner-classes, there's also Inner-enums
--
var result = '';
foam.CLASS({
  name: 'InnerEnumTest',
  enums: [
    { name: 'InnerEnum', values: [
    { name: 'OPEN',   label: 'Open'   },
    { name: 'CLOSED', label: 'Closed' }
    ] }
  ],
  methods: [
    function init() {
      // access from within the outer class
      result += this.InnerEnum.OPEN + " / " + this.InnerEnum.CLOSED;
    }
  ]
});
InnerEnumTest.create();
log(result);


##  Inner Enum access
Inner-enums can only be accessed through the outer-class
--
log("Access through outer:", InnerEnumTest.InnerEnum.name);

// Inner-enums do not appear in the global namespace
log("Available globally?", !! globalThis.InnerEnum);


##  Pub Sub
Objects can publish events and subscribe to other objects
--
foam.CLASS({
  name: 'PubSubTest'
});
var o = PubSubTest.create();


##  Subscribing
Objects can publish events and subscribe to other objects
--
// Objects support pub() for publishing events,
// and sub() for subscribing to published events.
var globalCalls = 0;
var alarmCalls = 0;
var globalResult = '';
// Install a listener that listens to all events
// Listeners are called with a subscription object and the given
//   arguments from pub().
o.sub(function() {
  log('  global listener: ', [].join.call(arguments, ' '));
  globalCalls += 1;
  globalResult += ' a' + arguments.length;
});
// This listener will only fire if the first argument matches 'alarm'
o.sub('alarm', function() {
  log('  alarm: ', [].join.call(arguments, ' '));
  alarmCalls += 1;
});
log("Pub alarm:");
o.pub('alarm', 'on');
log("Pub lifecycle:");
o.pub('lifecycle', 'loaded');


##  Publish arguments
Any number of arguments can be published
--
// Test publishing with many args
log("Pub many arguments:");
o.pub(1);
o.pub(1,2);
o.pub(1,2,3);
o.pub(1,2,3,4);
o.pub(1,2,3,4,5);
o.pub(1,2,3,4,5,6);
o.pub(1,2,3,4,5,6,7);
o.pub(1,2,3,4,5,6,7,8);
o.pub(1,2,3,4,5,6,7,8,9);
o.pub(1,2,3,4,5,6,7,8,9,10);
o.pub(1,2,3,4,5,6,7,8,9,10,11);
// log(globalResult);


##  Topics
A Class can declare Topics that it publishes events for
--
foam.CLASS({
  name: 'TopicTest',
  topics: [ 'alarm' ]
});
var o = TopicTest.create();
var normalCalls = 0;
var topicCalls = 0;

o.sub('alarm', function(_, __, state) {
  log('alarm: ', state);
  normalCalls += 1;
});
// The next line uses the Topic and is slightly shorter than the equivalent above.
o.alarm.sub(function(_, __, state) {
  log('alarm (topic): ', state);
  topicCalls += 1;
});
o.alarm.pub('on');
o.pub('alarm', 'off');


##  propertyChange
Objects implicitly pub events on the propertyChange topic when property values change
--
foam.CLASS({
  name: 'PropertyChangeTest',
  properties: [ 'a', 'b' ]
});
o = PropertyChangeTest.create();
// propertyChange event listeners are called with:
//   sub  - the subscription object, which can be detach()ed to end
//            the subscription
//   p    - the string 'propertyChange'
//   name - the name of the changed property
//   dyn  - a dynamic access object to .get() the current value and
//            getPrev() the pre-change value

var anyChangeCalls = 0;
var propAChangeCalls = 0;
// Listen for all propertyChange events:
o.propertyChange.sub(function(sub, p, name, dyn) {
  log('propertyChange: ', p, name, dyn.getPrev(), dyn.get());
  anyChangeCalls += 1;
});

// Listen for only changes to the 'a' Property:
o.propertyChange.sub('a', function(sub, p, name, dyn) {
  log('propertyChange.a: ', p, name, dyn.getPrev(), dyn.get());
  propAChangeCalls += 1;
});

o.a = 42;
o.b = 'bar';
o.a++;


##  Unsubscribe from subscriber
1. Call .detach() on the Detachable that sub() returns
--

var calls = 0;
var l = function(sub, name) {
  log('Event:', name);
  calls += 1;
};

var sub = o.sub(l);
o.pub('fire');
sub.detach();
o.pub("fire again, but nobody's listenering");


##  Unsubscribe from listener
2. Detach the subscription, which is supplied to the listener
--
var calls = 0;
var once = function(sub, name) {
  log('Event:', name);
  calls += 1;
  // stop listening
  sub.detach();
};

o.sub(once);
o.pub('fire');
o.pub("fire again, but nobody's listening");


##  Unsubscribe with oneTime helper
3. If you only want to receive the first event, use foam.events.oneTime()
--
// If you only want to receive the first event, decorate your
// listener with foam.events.oneTime() and it will cancel the subscription
// when it receives the first event.
o.sub(foam.events.oneTime(function() {
  log.apply(log, arguments);
}));

o.pub('fire');
o.pub("fire again, but nobody's listenering");


##  Slot get
Slots are like Object-Oriented pointers
--
// A property's slot is accessed as 'name'$.
// get() is used to dereference the value of a slot
var p = Person.create({ name: 'Bob' });
var dyn = p.name$;
log("Person name:", dyn.get());


##  Slot set
set() is used to set a Slot's value
--
var p = Person.create({ name: 'Bob' });
var dyn = p.name$;
dyn.set('John'); // sets p.name implicitly
log("Name after set:", p.name, "get():", dyn.get());


##  Slot get with slot method
Calling obj.slot('name') is the same as obj.name$
--
var p = Person.create({name: 'Bob'});

var dyn = p.slot('name'); // same as p.name$
log("slot value:", dyn.get());

dyn.set('John');
log("after set:", dyn.get());


##  Slot nesting
Slots can be nested with dot() to bind to a sub-property of a property value
--
// Nested slots
foam.CLASS({ name: 'Holder', properties: [ 'data' ] });
var p1 = Person.create({name: 'John'});
var p2 = Person.create({name: 'Paul'});
var h = Holder.create({data: p1});
// Bind to the 'name' of whatever h.data will be, even if it changes
var s = h.data$.dot('name');

// Note that this listener is called when we swap p2 for p1, since
//  p2.name is not the same as p1.name.
var changes = "";
s.sub(function() {
  log('    h.data.name change: ', h.data.name);
  changes += h.data.name + " ";
});

log('Set to p1:');

log("  Initial s:", s.get());

s.set('George');
log("  After setting s, p1.name:", p1.name);

p1.name = 'Ringo';
log("  After setting p1.name, s:", s.get());

log('Setting to p2, which has a different name:');

h.data = p2;
log("  Initial s:", s.get());

s.set('George');
log("  After setting s, p2.name:", p2.name);

p2.name = 'Ringo';
log("  After setting p2.name, s:", s.get());


##  Subscription nesting
Subscribe using valueSub() of the slot, automatically resubscribed as the value changes
--
// Subscribe to the value of the slot data$, removing the
// subscription and resubscribing to the new value of data$
// if it changes.
foam.CLASS({ name: 'Holder', properties: [ 'data' ] });
var p1 = Person.create({name: 'John'});
var p2 = Person.create({name: 'Paul'});
var h = Holder.create({data: p1});
var changes = "";
h.data$.valueSub(function(e, topic, name, dyn) {
  log('sub change: ', e.src.name, topic, name);
  changes += topic + ':' + (dyn && dyn.get()) + ' ';
});

p1.name = 'Peter';
p2.name = 'Mary';
h.data = p2;
p1.name = 'James';
p2.name = 'Ringo';
p2.pub('test','event');


##  Data Binding two way
Assiging one slot to another binds their values
--
// Two-Way Data-Binding
// Slots can be assigned, causing two values to be
// bound to the same value.
var p1 = Person.create(), p2 = Person.create();

p1.name$ = p2.name$;
p1.name = 'John'; // also sets p2.name
log("Assigned first:", p1.name, p2.name);

p2.name = 'Steve'; // also sets p1.name
log("Assigned second: ", p1.name, p2.name);


##  Data Binding linkFrom
Another way to link two Slots is to call .linkFrom() on one of them
--
var p1 = Person.create({ name: 'p1' });
var p2 = Person.create({ name: 'p2' });
var d = p1.name$.linkFrom(p2.name$);
p1.name = 'John';
log("Assigned first:", p1.name, p2.name);


##  Data Binding linkFrom unbind
linkFrom/To() returns a detachable that unbinds the slots
--
// But this style of link can be broken by calling .detach()
// on the object return from .linkFrom/To().
d.detach();
p2.name = 'Steve';
log("No longer bound:", p1.name, p2.name);


##  Data Binding linkTo
linkTo() is the same as linkFrom(), except that the initial value is taken from 'this' instead of the other object
--
// linkTo() is the same as linkFrom(), except that the initial value
// is taken from 'this' instead of the other object.
var p1 = Person.create({ name:'p1' }), p2 = Person.create({ name:'p2' });
var d = p1.name$.linkTo(p2.name$);
log("After linkTo:", p1.name, p2.name);
var name2 = p2.name;

p1.name = 'John';
log("Assigned first:", p1.name, p2.name);


##  Data Binding relateTo
Two values can be linked through relateTo
--
// Two values can be linked through a relationship,
// which provides functions to adapt between the two values.
foam.CLASS({
  name: 'Temperature',
  properties: [
    { class: 'Float', name: 'f' },
    { class: 'Float', name: 'c' }
  ],
  methods: [
    function init() {
      this.f$.relateTo(
        this.c$,
        function f2c(f) {
          log('f2c', f); return 5/9 * ( f - 32 );
        },
        function c2f(c) {
          log('c2f', c); return 9/5 * c + 32;
        }
      );
    }
  ]
});

var t = Temperature.create();
log("Initial     f:", t.f, " c:", t.c);
t.f = 100;
log("Set(f=100)  f:", t.f, " c:", t.c);
t.c = 100;
log("Set(c=100)  f:", t.f, " c:", t.c);


##  Data Binding one way
The .follow() method binds in one direction only
--
// Calling .linkFrom()/.linkTo() creates a two-way data-binding, meaning a change in either
// value is reflected in the other.  But FOAM supports one-way data-binding as well.
// To do this, use the .follow() method.
var p1 = Person.create({ name:'p1' }), p2 = Person.create({ name:'p2' });
var d = p1.name$.follow(p2.name$);

p2.name = 'Ringo'; // Will update p1 and p2
p2.name = 'Paul'; // Will update p1 and p2
log('Assigned p2:', p1.name, p2.name);
p1.name = 'George'; // Will only update p1
log('Assigned p1:', p1.name, p2.name);
d.detach();


##  Data Binding one way initialization
Follow copies the initial value of the followed slot
--
p1 = Person.create();
p2 = Person.create({name:'John'});
log("Initial:", p1.name, p2.name);

p1.name$.follow(p2.name$);
log("After follow:", p1.name, p2.name);


##  Data Binding one way mapFrom
One-Way Data-Binding, with Map function (mapFrom)
--
var p1 = Person.create(), p2 = Person.create();
var d = p1.name$.mapFrom(p2.name$, function(n) {
  return n + "es";
});

p2.name = 'Ringo'; // Will update p1 and p2
log('Assigned second:', p1.name, p2.name);
p1.name = 'George'; // Will only update p1
log('Assigned first:', p1.name, p2.name);
d.detach();


##  Data Binding one way mapTo
One-Way Data-Binding, with Map function (mapTo)
--
// The reverse of mapFrom(), mapTo() takes the value of this,
// mapping it and assigning to the target.
var p1 = Person.create(), p2 = Person.create();
var d = p2.name$.mapTo(p1.name$, function(n) {
  return 'One' + n;
});

p2.name = 'Ringo'; // Will update p1 and p2
log("Assigned second:", p1.name, p2.name);
p1.name = 'George'; // Will only update p1
log("Assigned first:", p1.name, p2.name);
d.detach();


##  Slot isDefined
Slots also let you check if the value is defined by calling isDefined()
--
// Calling obj.name$.isDefined() is equivalent to obj.hasOwnProperty('name');
foam.CLASS({name: 'IsDefinedTest', properties: [ { name: 'a', value: 42 } ]});
var o = IsDefinedTest.create();
var dv = o.a$;
log("Default value only, isDefined?", dv.isDefined());
dv.set(99);
log("Set to 99, isDefined?", dv.isDefined());


##  Slot clear
You can reset a Slot to its default value by calling .clear()
--
// Calling obj.name$.clear() is equivalent to obj.clearProperty('name');
dv.clear();
log("After clearing:", dv.get(), dv.isDefined());


##  ConstantSlot
ConstantSlot creates an immutable slot
--
var s = foam.core.ConstantSlot.create({ value: 42 });
log("Intial value:", s.get());
s.value = 66;
s.set(66);
log("After set to 66:", s.get());


##  SimpleSlot
SimpleSlot creates a mutable slot.
--
var s = foam.core.SimpleSlot.create({ value: 42 });
log("Intial value:", s.get());
s.value = 66;
s.set(66);
log("After set to 66:", s.get());


##  PromiseSlot
PromiseSlot provides a declarative way of creating a slot that should contain the value of a promise when it resolves.
--
var promise = new Promise(function(resolve, reject) {
  globalThis.setTimeout(function() {
    resolve(66);
  }, 3000);
}).then((value) => {
  log('Promise resolved!', new Date());
  log('Slot value:', value);
});
log('Promise created.', new Date());
var s = foam.core.PromiseSlot.create({
  value: 42,
  promise: promise
});
log("Intial value of the slot:", s.get());
globalThis.setTimeout(() => {
  log('Value 1 second later, at ' + new Date() + ':', s.get());
}, 1000);
return promise;


##  ArraySlot
ArraySlot provides a way to group several slots together so that when any of them update we can invalidate.
--
var promise = new Promise(function(resolve, reject) {
  globalThis.setTimeout(() => resolve('bar'), 3000);
});
var s1 = foam.core.SimpleSlot.create({ value: 42 });
var s2 = foam.core.PromiseSlot.create({ value: 'foo', promise: promise });
var arraySlot = foam.core.ArraySlot.create({ slots: [s1, s2] });
log('Initial value:', arraySlot.get());
arraySlot.sub((detachable, eventName, propName, slot) => {
  log('Value updated to:', arraySlot.get());
});
s1.set(66);
return promise;


##  ProxySlot
ProxySlot provides a way to flatten/join a slot of a slot into what appears to be a slot of the inner slot's value. It lets you abstract away the inner slot.Using ProxySlot in this way is similar to how Promises that return Promises are automatically flattened/joined for you. However, in the case of slots, you need to explicitly use ProxySlot if you want this joining behaviour, otherwise you'll simply have a slot whose value is a slot. In this regard, slots are more flexible than Promises because it is up to the programmer to decide whether they want flattening/joining behaviour or not.
--
var s1 = foam.core.SimpleSlot.create({ value: 'fname' });
foam.CLASS({ name: 'Person', properties: ['fname', 'lname'] });
var p = Person.create({ fname: 'John', lname: 'Smith' });
var slotOfSlot = s1.map((propName) => {
  return p.slot(propName).map((propValue) => propName + ' = ' + propValue);
});
var proxySlot = foam.core.ProxySlot.create({ delegate$: slotOfSlot });
log('Value:', proxySlot.get());
s1.set('lname');
log('Value:', proxySlot.get());


##  Expression Slots
ExpressionSlot creates a Slot from a list of Slots and a function to combine them
--
foam.CLASS({ name: 'Person', properties: ['fname', 'lname'] });
var p = Person.create({ fname: 'John', lname: 'Smith' });
// When fname or lname changes, the new values are fed into the function
// to produce a new value for ExpressionSlot e
var e = foam.core.ExpressionSlot.create({
  args: [ p.fname$, p.lname$ ],
  code: function(f, l) { return f + ' ' + l; }
});

log("Intial e:", e.get());
var calls = 0;
e.sub(function() {
  log("e changed:", e.get());
  calls += 1;
});
p.fname = 'Steve';
p.lname = 'Jones';
log("Final e:", e.get());


##  Expression Slot with object
ExpressionSlot can use an object to supply the source slots
--
foam.CLASS({ name: 'Person', properties: [ 'f', 'l' ] });
var p = Person.create({ f:'John', l: 'Smith' });
// function arguments 'f' and 'l' are treated as property names on obj
var e = foam.core.ExpressionSlot.create({
  obj: p,
  code: function(f, l) { return f + ' ' + l; }
});
log("Initial e:", e.get());
e.sub(function() {
  log("e changed:", e.get());
});
p.f = 'Steve';
p.l = 'Jones';
log("Final e:", e.get());


##  Expression Slot unbinding
Detach the ExpressionSlot to prevent further updates
--
calls = 0;
e.detach();
log("e detached, setting f and l again...");
p.f = 'Bob';
p.l = 'Roberts';
log("Updates since detach:", calls);


##  Property Expression Class
The same functionality of ExpressionSlot is built into Properties
--
// Properties have the 'expression' feature
foam.CLASS({
  name: 'Person',
  properties: [
    'fname',
    'lname',
    {
      name: 'name',
      expression: function(fname, lname) { return fname + ' ' + lname; }
    }
  ]
});
var p = Person.create({ fname: 'John', lname: 'Smith' });


##  Property Expressions
Expression properties are invalidated whenever of their listed source values change
--
// Expression properties are invalidated
// whenever of their listed source values change, but are only recalculated
// when their value is accessed.
p.describe();
p.sub(function(sub, propChg, name) {
  log("Event:", propChg, name);
});
p.fname = 'Steve';
log(p.fname, p.lname, '=', p.name);
p.lname = 'Jones';
log(p.fname, p.lname, '=', p.name);


##  Property Expression setting
Expression properties can also be explicitly set, disabling the dynamic expression
--
log(p.name, p.hasOwnProperty('name'));
p.name = 'Kevin Greer';
log(p.name, p.hasOwnProperty('name'));
p.fname = 'Sebastian';
log(p.fname, p.lname, ':', p.name);


##  Property Expression
Clearing a set expression property reverts it to expression mode
--
p.name = "Joe"
log("Set directly:", p.name, "hasOwnProperty(name)?", p.hasOwnProperty('name'));
p.clearProperty('name');
log("After clearing:", p.name, "hasOwnProperty(name)?", p.hasOwnProperty('name'));


##  Detachables
Detachables or functions can be registered to be called when an object is detached.
--
// Detachables are objects with a detach() method, such as FObjects
// and sub()-returned subscriptions.
var o = foam.core.FObject.create();
var o2 = foam.core.FObject.create();
var detachs = '';

// onDetach adds a function to be called when the object is detached
o.onDetach(function() {
  log('detach 1');
  detachs += '1 ';
});
o2.onDetach(function() {
  log('detach 2');
  detachs += '2 ';
});

// cause o2 to be detached when o is detached
o.onDetach(o2);
o.detach();


##  Detachables idempotent
It doesn't hurt to try and detach an object more than once
--
var o = foam.core.FObject.create();
o.detach();
o.detach();


##  Detachables unsubscribe

--
// If an Object is detached, it will unsubscribe from any
// subscriptions which subsequently try to deliver events.
var source = foam.core.FObject.create();
var calls = 0;
foam.CLASS({
  name: 'Sink',
  listeners: [
    function l() {
      calls += 1;
      log('ping:', calls);
    }
  ]
});
var sink = Sink.create();
source.sub('ping', sink.l);
source.pub('ping');
source.pub('pong'); // There is no subscriber to the topic 'pong'
source.pub('ping');

// Detaching object and unsubscribing all subscribers
source.detach();
source.pub('ping');


##  Model validation extends refines
Extends and refines are mutually-exclusive
--
foam.CLASS({
  name: 'EandRTest',
  extends: 'FObject',
  refines: 'Model'
});
EandRTest.model_.validate();


##  Model validation property name exists
Properties must have names
--
foam.CLASS({
  name: 'ValidationTest',
  properties: [
    { name: '' }
  ]
});
ValidationTest.model_.validate();


##  Action validation names
Actions must have a name
--
foam.CLASS({
  name: 'ActionNameValidation',
  actions: [
    { name: '', code: function() {} }
  ]
});
ActionNameValidation.model_.validate();


##  Action validation code
Actions must have code
--
foam.CLASS({
  name: 'ActionCodeValidation',
  actions: [
    { name: 'test' }
  ]
});
ActionCodeValidation.model_.validate();


##  Model validation property slot name
Properties names must not end with $
--
foam.CLASS({
  name: 'DollarValidationTest',
  properties: [
    { name: 'name$' }
  ]
});
DollarValidationTest.model_.validate();


##  Model validation property constants
Property constants must not conflict
--
foam.CLASS({
  name: 'ConstantConflictTest',
  properties: [ 'firstName', 'FirstName' ]
});
ConstantConflictTest.model_.validate();


##  Model validation property same name
Properties must not have the same name
--
foam.CLASS({
  name: 'AxiomConflict1',
  properties: [ 'sameName', 'sameName' ]
});
AxiomConflict1.model_.validate();


##  Model validation same method name
Methods must not have the same name
--
foam.CLASS({
  name: 'AxiomConflict2',
  methods: [ function sameName() {}, function sameName() {} ]
});
AxiomConflict2.model_.validate();


##  Axiom validation same name
Axioms must not have the same name
--
//
foam.CLASS({
  name: 'AxiomConflict3',
  properties: [ 'sameName' ],
  methods: [ function sameName() {} ]
});
AxiomConflict3.model_.validate();


##  Axiom validation sub property type
A Property cannot be changed to a non-Property
--
foam.CLASS({
  name: 'AxiomChangeSuper',
  properties: [ 'sameName' ] // property
});
foam.CLASS({
  name: 'AxiomChangeSub',
  extends: 'AxiomChangeSuper',
  methods: [ function sameName() {} ] // now it's a method? no!
});
AxiomChangeSub.model_.validate();


##  Axiom validation class change
Warn if an Axiom changes its class
--
foam.CLASS({
  name: 'AxiomChangeSuper2',
  methods: [ function sameName() {} ]
});
foam.CLASS({
  name: 'AxiomChangeSub2',
  extends: 'AxiomChangeSuper2',
  properties: [ 'sameName' ]
});
AxiomChangeSub2.model_.validate();


##  Property validation single accessor
Properties may only have one of factory, value, expression, or getter; one of setter or adapt+preset+postset
--
var setTo;
foam.CLASS({
  name: 'PropertyValidationTest',
  properties: [
    {
      name: 't1',
      setter: function() { setTo = 1; this.instance_.t1 = 1; },
      adapt: function(_,v) { return v + 1; },
      preSet: function(_,v) { return v + 1; },
      postSet: function(_,v) { setTo = v + 1; }
    },
    {
      name: 't2',
      getter: function() { return 42; },
      factory: function() { return 43; },
      expression: function() { return 44; },
      value: 45
    }
  ]
});
PropertyValidationTest.model_.validate();


##  Property required
Properties marked required must have values supplied to create()
--
// Required
foam.CLASS({
  name: 'ValidationTest',
  properties: [
    { name: 'test', required: true }
  ]
});

var o = ValidationTest.create({test: '42'});
o.validate();
log('-');
var o = ValidationTest.create();
o.validate();


##  Unknown Properties
Unknown Model and Property properties are detected
--
foam.CLASS({
  name: 'ValidationTest',
  unknown: 'foobar',
  properties: [
    { name: 'test', unknown: 'foobar' }
  ]
});
ValidationTest.model_.validate();


##  Context create sub context
Contexts can be explicitly created with foam.createSubContext()
--
// The second argument of createSubContext() is an optional name for the Context
var Y1 = foam.createSubContext({
  key: 'value',
  fn: function() {
    return 'here';
  }
}, 'SubContext');
log("Y1:", Y1.key, Y1.fn());


##  Context context sub context
Sub-Contexts can be created from other Contexts
--
var Y2 = Y1.createSubContext({ key: 'value2' });
log("Y2:", Y2.key, Y2.fn());


##  Context sub context describe
A Context's contents can be inspected with .describe()
--
Y1.describe();
Y2.describe();


##  Imports Test Class
Imports are pulled from the context when an instance is created
--
foam.CLASS({
  name: 'ImportsTest',
  imports: [ 'myLogger' ],
  methods: [ function foo() {
    this.myLogger('log foo from ImportTest');
  } ]
});


##  Import context values
Classes can import values from the Context so that they can be accessed from this
--
// First try the import with no 'myLogger' in its context
try {
  var o = ImportsTest.create(); // should fail here, on object creation
  log('test created');
  o.foo();
} catch(e) {
  log('Could not import "myLogger" since nobody provided it.');
}

var lastLogMsg = "";
// Provide a 'myLogger' on a context
var Y = foam.createSubContext({ myLogger: function(msg) {
  log('log:', msg);
  lastLogMsg = msg;
}});

Y.myLogger('test');
// Using 'requires' supplies the context automatically, but for this
// example we supply the context explicitly.
var o = ImportsTest.create(null, Y); // create with context Y
o.foo();


##  Imports optional
Optional imports, marked with a ?, don't warn if not found
--
foam.CLASS({
  name: 'OptionalImportsTest',
  imports: [ 'myLogger?' ],
  methods: [ function foo() {
    this.myLogger('log foo from ImportTest');
  } ]
});
try {
  var o = OptionalImportsTest.create();
  log('Test created ok');
  log('Trying to use missing import...');
  o.foo(); // should fail here, on import use
} catch(e) {
  log('As expected, could not import "myLogger" since nobody provided it.');
}


##  Export context values
Classes can export values for use by objects they create
--
var calls = 0;
foam.CLASS({
  name: 'ExportsTest',
  requires: [ 'ImportsTest' ],
  exports: [ 'myLogger' ],
  methods: [
    function init() {
      this.ImportsTest.create().foo();
    },
    function myLogger(msg) {
      // this function is exported, thus available to object we create
      // (like ImportsTest in our init)
      log('ExportsTest logger call:', msg);
      calls += 1;
    }
  ]
});
ExportsTest.create();


##  Packages
Classes can specify a package
--
foam.CLASS({
  package: 'com.acme',
  name: 'Test',
  methods: [ function foo() {
    log('Hello, I am foo() from com.acme.Test');
  } ]
});
com.acme.Test.create().foo();


##  Requires
Classes should requires: other Classes they need to use
--
// Classes can requires: other Classes to avoid having to reference them
// by their fully-qualified names. The creation context (and thus our
// exports) is also automatically provided.
foam.CLASS({
  name: 'RequiresTest',
  requires: ['com.acme.Test' ],
  methods: [ function foo() {
    this.Test.create().foo();
  } ]
});

log("When required:");
RequiresTest.create().foo();


##  Requires as
Requires can use as to alias required Classes
--
// Use 'as' to pick the name to use on 'this'. If a required
// class is named the same as one of your properties or methods,
// or two required classes have the same name, you may be forced
// to specify the name with 'as':
foam.CLASS({
  name: 'RequiresAliasTest',
  requires: ['com.acme.Test as NotTest' ],
  methods: [ function foo() {
    this.NotTest.create().foo();
  } ]
});

log("Required as NotTest:");
RequiresAliasTest.create().foo();


##  Primary Key
Classes can have a unique-id or primary-key
--
// By default, this is simply the field named 'id'.
foam.CLASS({
  name: 'Invoice',
  properties: [ 'id', 'desc', 'amount' ]
});
var o = Invoice.create({ id: 1, desc: 'Duct Cleaning', amount: 99.99 });
log(o.id);


##  Primary Key ids
Use the ids property to specify that the primary key be something other than id
--
// You can also use the 'ids' property to specify that
// the primary key be something other than 'id'.
// In this case, 'id' will become an psedo-property for
// accessing the real 'invoiceId' property.
foam.CLASS({
  name: 'Invoice2',
  ids: [ 'invoiceId' ],
  properties: [ 'invoiceId', 'desc', 'amount' ]
});
var o = Invoice2.create({ invoiceId: 23, desc: 'Duct Cleaning', amount: 99.99 });
log("Id:", o.id, "invoiceId:", o.invoiceId);


##  Primary Key multipart Class
Multi-part unique identifiers are also supported by setting ids
--
foam.CLASS({
  name: 'Invoice3',
  ids: [ 'customerId', 'invoiceId' ],
  properties: [ 'customerId', 'invoiceId', 'desc', 'amount' ]
});


##  Primary Key multipart
Multi-part unique identifiers are also supported by setting ids
--
var o = Invoice3.create({customerId: 1, invoiceId: 1, desc: 'Duct Cleaning', amount: 99.99});
log("initial           id:", o.id, "customerId:", o.customerId, "invoiceId:", o.invoiceId);
// setting id propagates the changes to the properties that make up the
// multipart id:
o.id = [2, 3];
log("after setting id, id:", o.id, "customerId:", o.customerId, "invoiceId:", o.invoiceId);


##  Primary Key multipart comparison
Multi-part ids are comparable
--
var results = '';
results += Invoice3.ID.compare(
  Invoice3.create({customerId: 1, invoiceId: 2}),
  Invoice3.create({customerId: 1, invoiceId: 1}));

results += ", " + Invoice3.ID.compare(
  Invoice3.create({customerId: 1, invoiceId: 1}),
  Invoice3.create({customerId: 1, invoiceId: 2}));

results += ", " + Invoice3.ID.compare(
  Invoice3.create({customerId: 1, invoiceId: 1}),
  Invoice3.create({customerId: 1, invoiceId: 1}));

results += ", " + Invoice3.ID.compare(
  Invoice3.create({customerId: 2, invoiceId: 1}),
  Invoice3.create({customerId: 1, invoiceId: 1}));

results += ", " + Invoice3.ID.compare(
  Invoice3.create({customerId: 1, invoiceId: 1}),
  Invoice3.create({customerId: 2, invoiceId: 1}));

log("Comparison results:", results);


##  Class Id
A Class' id is a combination of its package and name
--
log("Test class id:", com.acme.Test.id);


##  Custom Axioms
Specify arbitrary Axioms for a Class with axioms:
--
// In addition the the built-in Axiom types, you can also
// specify arbitrary Axioms with 'axioms:'.
// This example adds the 'Singleton' axiom to make a class
// implement the Singleton patter (ie. there can only be
// one instance)
foam.CLASS({
  name: 'AxiomTest',
  axioms: [ foam.pattern.Singleton.create() ],
  methods: [ function init() {
    log('Creating AxiomTest');
  } ]
});

AxiomTest.create();
AxiomTest.create();
log("Same instance?", AxiomTest.create() === AxiomTest.create());


##  Custom Axioms inherit
Gain the custom axioms of a Class you extend
--
//
foam.CLASS({
  name: 'AxiomSubTest',
  extends: 'AxiomTest',
  methods: [ function init() {
    log('Creating AxiomSubTest');
  } ]
});
AxiomSubTest.create();
AxiomSubTest.create();
log("sub is same instance?", AxiomSubTest.create() === AxiomSubTest.create());
log("sub same as super?", AxiomSubTest.create() === AxiomTest.create());


##  Multiton
Add the Multion axiom to implement the Multiton pattern
--
// Multitons create one shared instance per value, based on the given
// property.
foam.CLASS({
  name: 'Color',
  axioms: [ foam.pattern.Multiton.create({ property: 'color' }) ],
  properties: [ 'color' ],
  methods: [ function init() {
    log('Creating Color:', this.color);
  } ]
});

var red1 = Color.create({color: 'red'});
var red2 = Color.create({color: 'red'});
var blue = Color.create({color: 'blue'});

log('reds same?', red1 === red2);
log('red same as blue?', red1 === blue);


##  Object UID
All Objects have a unique identifier, accessible with the .$UID property
--
var a = {}, b = [], c = Person.create();
log(a.$UID, b.$UID, c.$UID);


##  Console log listener
foam.events.consoleLog() returns a convenient listener that logs
--
// foam.events.consoleLog
foam.CLASS({name: 'ConsoleLogTest'});
var o = ConsoleLogTest.create();
o.sub(foam.events.consoleLog());
o.pub();
o.pub('foo');
o.pub('foo','bar');


##  Function memoize1
foam.Function.memoize1() memoizes a one-argument function
--
// if called again with the same argument, the previously generated
// value will be returned rather than calling the function again.
var calls = 0;
var f = foam.Function.memoize1(function(x) {
  calls += 1;
  log('calculating ', x, "=>", x*x);
  return x*x;
});

log(f(2));
log(f(2));
log(f(4));
log("Total number of calls:", calls);


##  Function memoize1 one arg only
A call to memoize1'ed function with no arguments or too many arguments will trigger a failed assertion
--
f();
f(1, 2);


##  Function argsStr
foam.Function.argsStr() returns a function's arguments as a string
--
var f = function(a, b, fooBar) { };
var argsAsStr = foam.Function.argsStr(f);
log('Function args:', argsAsStr);


##  Function argNames
foam.Function.argNames() returns a function's arguments an an array
--
var f = function(a, b, fooBar) { };
var argsAsArray = foam.Function.argNames(f);
log('Function args array:', argsAsArray);


##  String constantize
foam.String.constantize converts strings from camelCase to CONSTANT_FORMAT
--
log('foo      =>', foam.String.constantize('foo'));
log('fooBar   =>', foam.String.constantize('fooBar'));
log('fooBar12 =>', foam.String.constantize('fooBar12'));


##  String capitalize
foam.String.capitalize capitalizes the first letter of a string
--
log(foam.String.capitalize('Abc def'));
log(foam.String.capitalize('abc def'));


##  String labelize
foam.String.labelize converts from camelCase to labels
--
log(foam.String.labelize('camelCase'));
log(foam.String.labelize('firstName'));
log(foam.String.labelize('someLongName'));


##  String multiline
foam.String.multiline lets you build multi-line strings from function comments
--
log(foam.String.multiline(function(){/*This is
a
multi-line
string*/}));


##  String pad
foam.String.pad() pads a string to the specified length
--
var s = foam.String.pad('foobar', 10);
log("padded  10:", '"' + s + '"', s.length);

// pad() is right justifying if given a negative number
var s = foam.String.pad('foobar', -10);
log("padded -10:", '"' + s + '"', s.length);


##  Template basics
Templates use a JSP syntax to insert properties and code
--
//
foam.CLASS({
  name: 'TemplateTest',
  properties: [
    'name'
  ],
  templates: [
    {
      name: 'hello',
      template: 'Hello, my name is <%= this.name %>.'
    }
  ]
});

var o = TemplateTest.create({ name: 'Adam' });
log(o.hello());


##  Template arguments
Templates can be declared to accept arguments
--
foam.CLASS({
  name: 'TemplateTest',
  properties: [
    'name'
  ],
  templates: [
    {
      name: 'greet',
      args: [
        'stranger'
      ],
      template: 'Hello <%= stranger %>, my name is <%= this.name %>.'
    }
  ]
});

var o = TemplateTest.create({ name: 'Adam' });
log(o.greet("Bob"));


##  Template nesting
Templates can be called from other templates. Include output as the first argument.
--
foam.CLASS({
  name: 'TemplateTest',
  properties: [ 'name' ],
  templates: [
    {
      name: 'greeter',
      args: [ 'stranger' ],
      template: 'Hello <%= stranger %>'
    },
    {
      name: 'greet',
      args: ['stranger'],
      // 'output' is an implicit argument you must pass when calling one template
      // from another.
      template: '<% this.greeter(output, stranger); %>, my name is <%= this.name %>'
    }
  ]
});

var o = TemplateTest.create({ name: 'Adam' });
log(o.greet("Alice"));


##  Template code
Template can use raw JS code for loops and control structures
--
foam.CLASS({
  name: 'TemplateTest',
  properties: [ 'name' ],
  templates: [
    {
      name: 'complexTemplate',
      template: 'Use raw JS code for loops and control structures' +
        '<% for ( var i = 0 ; i < 10; i++ ) { %>\n' +
        'i is: "<%= i %>" <% if ( i % 2 == 0 ) { %> which is even!<% } '+
        '} %>' +
        '\n\n' +
        'Use percent signs to shortcut access to local properties\n' +
        'For instance, my name is %%name\n'
    }
  ]
});

log(TemplateTest.create({ name: 'Adam' }).complexTemplate());


##  Template mutliline
Multi-line templates can be defined as function comments
--
      foam.CLASS({
        name: 'MultiLineTemplateTest',
        properties: [ 'name' ],
        templates: [
          {
            name: 'complexTemplate',
            template: `
Use raw JS code for loops and control structures
<% for ( var i = 0 ; i < 10; i++ ) { %>
i is: "<%= i %>" <% if ( i % 2 == 0 ) { %> which is even!<% }
} %>
Use percent signs to shortcut access to local properties
For instance, my name is %%name
            `
          }
        ]
      });
      log(MultiLineTemplateTest.create({ name: 'Adam' }).complexTemplate());


##  Create JSON Class
Conversion to and from JSON is supported
--
foam.CLASS({
  name: 'JSONTest',
  properties: [
    { name: 'name', shortName: 'n' },
    { class: 'Int', name: 'age', shortName: 'a' },
    { class: 'StringArray', name: 'children', shortName: 'cs' },
    { name: 'name That Needs Quoting' },
    { name: 'undefined' },
    { name: 'defined' },
    { class: 'String', name: 'undefinedString' },
    { class: 'String', name: 'definedString' },
    { class: 'String', name: 'defaultString', value: 'default' },
    { class: 'Int', name: 'undefinedInt' },
    { class: 'Int', name: 'definedInt' },
    { class: 'Int', name: 'defaultInt', value: 3 },
    { class: 'Float', name: 'undefinedFloat' },
    { class: 'Float', name: 'definedFloat' },
    { class: 'Float', name: 'defaultFloat', value: 3.14 },
    { class: 'Boolean', name: 'undefinedBoolean' },
    { class: 'Boolean', name: 'trueBoolean' },
    { class: 'Boolean', name: 'falseBoolean' },
    { class: 'Boolean', name: 'defaultBoolean', value: true },
    { class: 'Function', name: 'undefinedFunction' },
    { class: 'Function', name: 'definedFunction' },
    { name: 'undefinedFObject' },
    { name: 'definedFObject' },
    { name: 'transient', transient: true },
    { name: 'networkTransient', networkTransient: true },
    { name: 'storageTransient', storageTransient: true },
//    { name: '' },
  ]
});


##  JSON parse
Use foam.json.parse(someJSONobject) to convert to an FObject
--
var o = foam.json.parse({
  class: 'JSONTest',
  name: 'John',
  age: 42,
  children: ['Peter', 'Paul']});
o.describe();


##  JSON output
Use foam.json.stringify(fobject) to serialize an FObject to a JSON string
--
o = JSONTest.create({
  name: 'John',
  age: 42,
  children: ['Peter', 'Paul'],
  "name That Needs Quoting": 42,
  defined: 'value',
  definedString: 'stringValue',
  definedInt: 42,
  defaultInt: 3,
  definedFloat: 42.42,
  defaultFloat: 3.14,
  trueBoolean: true,
  falseBoolean: false,
  defaultBoolean: true,
  definedFunction: function plus(a, b) { return a + b; },
  definedFObject: JSONTest.create({
    name: 'Janet',
    age: 32,
    children: [ 'Kim', 'Kathy' ]
  }),
  transient: 'transient value',
  networkTransient: 'network transient value',
  storageTransient: 'storage transient value'
});
// Default JSON formatting
log(foam.json.stringify(o));



##  JSON output modes
Different outputters support suppressing properties, transients, and other options
--
// Outputters have different defaults for formatting, which properties
// to output, etc. You can clone one and change these settings on the
// outputter to customize your JSON output.

log('\nConvert to a JSON object (instead of a String):');
log(foam.json.stringify(JSONTest.create(foam.json.objectify(o))));

log('\nAs a method on Objects:');
log(o.stringify());

log('\nPretty-printed output:');
log(foam.json.Pretty.stringify(o));

log('\nDisable class name output by cloning your own outputter:');
log(foam.json.Pretty.clone().copyFrom({ outputClassNames: false }).stringify(o));

log('\nStrict output:');
log(foam.json.Strict.stringify(o));

log('\nStrict-but-still-readable output:');
log(foam.json.PrettyStrict.stringify(o));

log('\nCompact output:');
log(foam.json.Compact.stringify(o));

log('\nShort-name (very compact) output:');
log(foam.json.Short.stringify(o));

log('\nNetwork (network-transient properties omitted) output:');
log(foam.json.Network.stringify(o));

log('\nStorage (storage-transient properties omitted) output:');
log(foam.json.Storage.stringify(o));


##  Graphics Support
CViews enable canvas rendering
--

foam.CLASS({
  name: 'GraphicsDemo',
  extends: 'foam.graphics.CView',
  requires: [
    'foam.graphics.Arc',
    'foam.graphics.Box',
    'foam.graphics.Circle',
    'foam.graphics.CView',
    'foam.graphics.Gradient'
  ],
  properties: [
    [ 'width', 500 ],
    [ 'height', 500 ],
    {
      name: 'children',
      factory: function() {
        var objects = [
          this.Arc.create({
            start: 0,
            end: 1.5*Math.PI,
            radius: 40
          }),
          this.Circle.create({
            color: this.Gradient.create({
              radial: true,
              x0: 0, y0: 0, r0: 10,
              x1: 0, y1: 0, r1: 100,
              colors: [
                [0, 'green'],
                [0.4, 'blue'],
                [0.6, 'red'],
                [1, 'white']
              ]
            }),
            border: '',
            radius: 100,
            x: 300,
            y: 300
          }),
          this.Box.create({
            color: this.Gradient.create({
              radial: false,
              x0: 0, y0: 0,
              x1: 100, y1: 100,
              colors: [
                [0, 'black'],
                [1, 'white']
              ]
            }),
            width: 100,
            height: 100,
            originX: 50,
            originY: 50,
            x: 100,
            y: 400,
            children: [
              this.Circle.create({
                color: 'red',
                x: 30,
                y: 30,
                radius: 10
              }),
              this.Circle.create({
                color: 'red',
                x: 70,
                y: 30,
                radius: 10
              }),
              this.Circle.create({
                color: 'red',
                x: 30,
                y: 70,
                radius: 10
              }),
              this.Circle.create({
                color: 'red',
                x: 70,
                y: 70,
                radius: 10
              }),
              this.Circle.create({
                color: 'red',
                x: 50,
                y: 50,
                radius: 10
              })
            ]
          })
        ];
        return objects;
      }
    },
    {
      name: 'counter',
      value: 0
    }
  ],
  listeners: [
    {
      name: 'step',
      isFramed: true,
      code: function() {
        this.counter += 0.01
        this.children[0].rotation += 0.1;
        this.children[0].x = 150 + 50 * Math.cos(this.counter);
        this.children[0].y = 150 + 50 * Math.sin(this.counter);
        this.children[1].skewX = Math.sin(this.counter);
        this.children[2].scaleX = 0.5 + 0.5 * Math.abs(Math.cos(this.counter));
        this.children[2].scaleY = 0.5 + 0.5 * Math.abs(Math.sin(this.counter));
        this.children[2].rotation += 0.01;
        this.step();
        this.invalidated.pub();
      }
    }
  ]
});
/*
var g = GraphicsDemo.create();
g.write();
g.step();
*/

## By Example
##  Test Class
Define a new class with foam.CLASS
--
foam.CLASS({
  name: 'Test',
  properties: [
    // short-form
    'a',
    // long-form
    {
      name: 'b'
    }
  ],
  methods: [
    // short-form
    function f1() { return 1; },
    // long-form
    {
      name: 'f2',
      code: function() { return 2; }
    }
  ]
});


##  Test describe
Use class.describe() to learn about the class
--
Test.describe();


##  Test create
Create an instance of Test
--
var o = Test.create();
log("Class: ", o);
log('a: ' + o.a + ', b: ' + o.b);


##  Test create with values
Create an instance with a map argument to initialize properties
--
var o = Test.create({ a: 3, b: 'hello' });
log("Class: ", o);
log('a: ' + o.a + ', b: ' + o.b);


##  Class reference
Objects have a reference to their class in .cls_
--
log("Class object:", o.cls_);


##  Test isInstance
Test Class membership with Class.isInstance()
--
log('Test.isInstance(o)?', Test.isInstance(o));
log('Test.isInstance("foo")?', Test.isInstance("Test"));


##  Test Methods
Call Methods on the Test instance
--
log("Methods return: ", o.f1(), o.f2());


##  Update Properties
Properties accept value changes as normal
--
o.a++;
o.b = 'bye';
log('New values: a: ' + o.a + ', b: ' + o.b);


##  Test copyFrom
Multiple properties can be updated at once using copyFrom()
--
o.copyFrom({a: 42, b: 'rosebud'});
log('New values: a: ' + o.a + ', b: ' + o.b);


##  Test toString
Call toString on an object
--
log("toString:", o.toString());


##  Describe instance
Call describe() on an object to see its Property values
--
o.describe();


##  Properties and Methods are types of Axioms
Get an array of all Axioms belonging to a Class by calling getAxioms
--
Test.getAxioms().forEach(function(a) {
  log(a.cls_ && a.cls_.name, a.name);
});


##  Test getAxiomByName
Find an Axiom for a class using getAxiomByName
--
var a = Test.getAxiomByName('a');
log(a.cls_.name, a.name);


##  Test getAxiomsByClass
Find all Axioms of a particular class using getAxiomsByClass
--
Test.getAxiomsByClass(foam.core.Method).forEach(function(a) {
  log(a.cls_ && a.cls_.name, a.name);
});


##  Test Property constants
Properties are defined on the class as constants
--
log("Method CODE property constant:", foam.core.Method.CODE);
foam.core.Method.CODE.describe();


##  Property mapping
Property constants contain map functions
--
// foam.core.Method.NAME.f(obj) returns obj.name
log("Method names in Test:",
  Test
    .getAxiomsByClass(foam.core.Method)
    .map(foam.core.Method.NAME.f)
    .join(', ')
);


##  Property comparators
Property constants contain comparators
--
// foam.core.Method.NAME.compare is a compare function
// that properly compares values of NAME.
log("Method names in Test, sorted:",
  Test
    .getAxiomsByClass(foam.core.Method)
    .sort(foam.core.Method.NAME.compare)
    .map(foam.core.Method.NAME.f)
    .join(', ')
);


##  Test init
If a Class defineds an init() method, it's called when an object is created.
--
foam.CLASS({
  name: 'InitTest',
  properties: [ 'a' ],
  methods: [ function init() { this.a = 'just born!'; } ]
});
var o = InitTest.create();
log("Initialized value:", o.a);


##  Create default values
Default Values can be defined for Properties
--
foam.CLASS({
  name: 'DefaultValueTest',
  properties: [
    { name: 'a', value: 42 },
    { name: 'b', value: 'foo' },
    { name: 'c' }
  ]
});
var o = DefaultValueTest.create();
log("Values:", o.a, o.b, o.c);


##  Test hasOwnProperty
FObject.hasOwnProperty() tells you if a Property has been set
--
log("Before setting:", o.hasOwnProperty('a'), o.hasOwnProperty('b'), o.hasOwnProperty('c'));
o.a = 99;
o.c = 'test';
log("After setting a, c:", o.hasOwnProperty('a'), o.hasOwnProperty('b'), o.hasOwnProperty('c'));


##  Test clearProperty
FObject.clearProperty() reverts a value back to its value
--
log("Before clearing:", o.hasOwnProperty('a'), o.a);
o.clearProperty('a');
log("After clearing:", o.hasOwnProperty('a'), o.a);


##  Create factory test
Properties can have factory methods which create their initial value when they are first accessed.
--
var factoryCount = 0;
foam.CLASS({
  name: 'FactoryTest',
  properties: [
    {
      name: 'a',
      factory: function() { factoryCount++; return 42; }
    }
  ]
});
var o = FactoryTest.create();


##  Test factory running
Factories run once when the property is first accessed
--
log("Before:    factory run count:", factoryCount);
log("Value:", o.a, " factory run count:", factoryCount);
// Factory not called value accessed second time:
log("Again:", o.a, " factory run count:", factoryCount);


##  Test factory not run
Factories do not run if the value is set before being accessed
--
// Value supplied in create()
o = FactoryTest.create({a: 42});
log("Value:", o.a, " factory run count:", factoryCount);

// Value set before first access
o = FactoryTest.create();
o.a = 99;
log("Value:", o.a, " factory run count:", factoryCount);


##  FactoryTest
Factory is called again if clearProperty() called
--
var o = FactoryTest.create();
log("Run factory: ", o.a);
log(" factory run count:", factoryCount);
o.clearProperty('a');
log("Again:       ", o.a);
log(" factory run count:", factoryCount);


##  Property Getters and Setters
Properties can define their own getter and setter functions
--
foam.CLASS({
  name: 'GetterSetter',
  properties: [
    'radius',
    {
      name: 'diameter',
      getter: function() {
        return this.radius * 2;
      },
      setter: function(diameter) {
        this.radius = diameter / 2;
      }
    }
  ]
});
var o = GetterSetter.create();

o.diameter = 10;
log("r:", o.radius, "d:", o.diameter);

o.radius = 10;
log("r:", o.radius, "d:", o.diameter);



##  Property Adapt
The adapt function is called on a property value update
--
// Properties can specify an 'adapt' function which is called whenever
// the properties' value is updated. It's the adapt function's responsibility
// to convert or coerce the type if necessary.

// Both the previous value of the property and the proposed new value are
// passed to adapt.  Adapt returns the desired new value, which may be different
// from the newValue it's provided.
foam.CLASS({
  name: 'AdaptTest',
  properties: [
    {
      name: 'flag',
      adapt: function(oldValue, newValue) {
        log('Adapt old:', oldValue, "to new:", newValue);
        // adapt to a boolean
        return !! newValue;
      }
    }
  ]
});
// adapt called once from the flag:true initializer here
var o = AdaptTest.create({ flag: true });

// adapt called again to adapt null
o.flag = null;
log("Adapted value:", o.flag);


##  Property preSet
The preSet function is called on a property update, after adapt
--
// Properties can specify a 'preSet' function which is called whenever
// the properties' value is updated, just after 'adapt', if present.

// Both the previous value of the property and the proposed new value are
// passed to preSet.  PreSet returns the desired new value, which may be different
// from the newValue it's provided.
foam.CLASS({
  name: 'PreSetTest',
  properties: [
    {
      name: 'a',
      preSet: function(oldValue, newValue) {
        log('preSet p1');
        return newValue + "y";
      }
    }
  ]
});
var o = PreSetTest.create({ a: 'Smith' });
log(o.a);

o.a = 'Jones';
log(o.a);


##  Property postSet
The postSet function is called after a property update
--
// Properties can specify a 'postSet' function which is called after
// the properties' value is updated.  PostSet has no return value and
// cannot stop the newValue from taking effect, since postSet it is
// called after the value has been set.
var lastPostSetValue;
foam.CLASS({
  name: 'PostSetTest',
  properties: [
    {
      name: 'a',
      postSet: function(oldValue, newValue) {
        log('postSet old:', oldValue, "new:", newValue);
        // this.a will match the newValue, since the set is already
        // complete
        lastPostSetValue = this.a;
      }
    }
  ]
});
var o = PostSetTest.create({ a: 'Smith' });
o.a = 'Jones';
o.a = 'Green';


##  Property adapt pre post
Properties can define adapt, preSet, and postSet all at once
--
var lastPostSetValue;
foam.CLASS({
  name: 'AdaptPrePostTest',
  properties: [
    {
      name: 'a',
      adapt: function(oldValue, newValue) {
        log('adapt old:', oldValue, 'new:', newValue);
        return newValue + 1;
      },
      preSet: function(oldValue, newValue) {
        log('preSet old:', oldValue, 'new:', newValue);
        return newValue + 2;
      },
      postSet: function(oldValue, newValue) {
        log('postSet old:', oldValue, 'new:', newValue);
        lastPostSetValue = this.a;
      }
    }
  ]
});
var o = AdaptPrePostTest.create();
o.a = 1;
o.a = 10;


##  Create constant test
Classes can define Constants
--
foam.CLASS({
  name: 'ConstantTest',
  constants: {
    MEANING_OF_LIFE: 42,
    FAVOURITE_COLOR: 'green'
  }
});
var o = ConstantTest.create();
log("Constant values:", o.MEANING_OF_LIFE, o.FAVOURITE_COLOR);


##  Constants Class access
Constants can also be accessed from the Class
--
log("ConstantTest constants:", ConstantTest.MEANING_OF_LIFE, ConstantTest.FAVOURITE_COLOR);
log("o.cls_ constants:", o.cls_.MEANING_OF_LIFE, o.cls_.FAVOURITE_COLOR);


##  Constants are constant
Constants are constant, and cannot be assigned
--
o.MEANING_OF_LIFE = 43;
log("Constant after setting to 43:", o.MEANING_OF_LIFE);


##  Person Class
A basic Person class
--
// Methods in subclasses can override methods from ancestor classes, as is
// done below with toString().  Employee.toString() calls its parent classes
// toString() method by calling 'this.SUPER()'.
foam.CLASS({
  name: 'Person',
  properties: [ 'name', 'sex' ],
  methods: [
    function toString() { return this.name + ' ' + this.sex; }
  ]
});


##  Create Person and Employee
Classes can be subclassed with extends
--
// Methods in subclasses can override methods from ancestor classes, as is
// done below with toString().  Employee.toString() calls its parent classes
// toString() method by calling 'this.SUPER()'.
foam.CLASS({
  name: 'Employee',
  extends: 'Person',
  properties: [ 'salary' ],
  methods: [
    function toString() { return this.SUPER() + ' ' + this.salary; }
  ]
});

var p = Person.create({name: 'John', sex: 'M'});
log("Person:", p.toString());

var e = Employee.create({name: 'Jane', sex: 'F', salary: 50000});
log("Employee:", e.toString());


##  Test SubClass
Test if one class is a sub-class of another
--
log("Is Employee a subclass of Person?", Person.isSubClass(Employee));
log("Is Person a subclass of Employee?", Employee.isSubClass(Person));


##  Test SubClass self
A Class is considered a sub-class of itself
--
log("Is Person a subclass of Person?", Person.isSubClass(Person));


##  Test FObject SubClass
FObject is the root class of all other classes
--
log("Is Employee an FObject?", foam.core.FObject.isSubClass(Employee));
log("Is Person an FObject?", foam.core.FObject.isSubClass(Person));


##  Test isSubClass and package
isSubClass() isn't confused by classes with the same name in different packages
--
foam.CLASS({
  package: 'com.acme.package',
  name: 'Person'
});
// The two Person classes are independent of each other
log("Is Person a packaged-Person?", com.acme.package.Person.isSubClass(Person));
log("Is packaged-Person a Person?", Person.isSubClass(com.acme.package.Person));


##  Test isSubClass and interfaces
isSubClass() works for interfaces
--
foam.CLASS({
  package: 'test',
  name: 'ThingI',
  methods: [ function foo() { log('Called ThingI.foo()'); } ]
});
foam.CLASS({
  package: 'test',
  name: 'C1',
  implements: [ 'test.ThingI' ]
});
log("Is C1 a ThingI?", test.ThingI.isSubClass(test.C1));


##  Test isSubClass sub interfaces
isSubClass() works for sub-interfaces
--
foam.CLASS({
  package: 'test',
  name: 'Thing2I',
  implements: [ 'test.ThingI' ]
});
foam.CLASS({
  package: 'test',
  name: 'Thing3I',
  implements: [ 'test.ThingI' ]
});
foam.CLASS({
  package: 'test',
  name: 'C2',
  implements: [ 'test.Thing2I' ]
});
var o = test.C2.create();
o.foo();

log("Is C2 a ThingI?", test.ThingI.isSubClass(test.C2));
log("Is C2 a Thing2I?", test.Thing2I.isSubClass(test.C2));
log("Is C2 a Thing3I?", test.Thing3I.isSubClass(test.C2));


##  Test isInstance sub interfaces
isInstance() works for sub-interfaces
--
log("Is o a ThingI?", test.ThingI.isInstance(o));
log("Is o a Thing2I?", test.Thing2I.isInstance(o));
log("Is o a Thing3I?", test.Thing3I.isInstance(o));
log("Is o a C2?", test.C2.isInstance(o));


##  Package imports exports demo
Package and imports/exports demo
--
foam.CLASS({
  package: 'demo.bank',
  name: 'Account',
  imports: [ 'reportDeposit' ],
  properties: [
    { name: 'id'      },
    { name: 'status'  },
    { name: 'balance', value: 0 }
  ],
  methods: [
    {
      name: "setStatus",
      code: function (status) {
        this.status = status;
      }
    },
    {
      name: "deposit",
      code: function (amount) {
        this.balance += amount;
        this.reportDeposit(this.id, amount, this.balance);
        log('Bank: ', this.__context__.Bank);
        return this.balance;
      }
    },
    {
      name: "withdraw",
      code: function (amount) {
        this.balance -= amount;
        return this.balance;
      }
    }
  ]
});
foam.CLASS({
  package: 'demo.bank',
  name: 'SavingsAccount',
  extends: 'demo.bank.Account',
  methods: [
    {
      name: "withdraw",
      code: function (amount) {
        // charge a fee
        this.balance -= 0.05;
        return this.SUPER(amount);
      }
    }
  ]
});
foam.CLASS({
  package: 'demo.bank',
  name: 'AccountTester',
  requires: [
    'demo.bank.Account as A',
    'demo.bank.SavingsAccount'
  ],
  imports: [ 'log as l' ],
  exports: [
    'reportDeposit',
    'as Bank' // exports 'this'
  ],
  methods: [
    function reportDeposit(id, amount, bal) {
      this.l('Deposit: ', id, amount, bal);
    },
    function test() {
      var a = this.A.create({id: 42});
      a.setStatus(true);
      a.deposit(100);
      a.withdraw(10);
      a.describe();
      var s = this.SavingsAccount.create({id: 43});
      s.setStatus(true);
      s.deposit(100);
      s.withdraw(10);
      s.describe();
    }
  ]
});
var a = demo.bank.AccountTester.create(null);
a.test();


##  Class Refinement
Refinement upgrades the existing class rather than create a new sub-class
--
// In addition to being extended, a Class can also be refined.
// Refinement upgrades the existing class rather than create a
// new sub-class. In the following example we add 'salary' to
// the person class, rather than creating a new Employee sub-class.
foam.CLASS({
  refines: 'Person',
  properties: [ { class: 'Float', name: 'salary', value: 0 } ],
  methods: [
    function toString() { return this.name + ' ' + this.sex + ' ' + this.salary; }
  ]
});
var n = Person.create({name: 'Bob', sex: 'M', salary: 40000});
log("New person after refinement:", n.toString());
// The already created person, John, now has a salary too!
log("Old person after refinement:", p.toString());


##  Refine a Property
Properties in classes can be changed in a refinement
--
log("Old type of Person.salary:", Person.SALARY.cls_.name);

// Change the salary property type, add a default value
foam.CLASS({
  refines: 'Person',
  properties: [ { name: 'salary', value: 30000 } ]
});

log("New type of Person.salary:", Person.SALARY.cls_.name);

var o = Person.create({name:'John'});
log("Now with default value:", o.salary);
log("And original person gets the default too:", p.salary);


##  Cannot Refine a Property Class
Refining Properties is currently unsupported and unlikely to be supported.
--
// Refining a type of Property after classes have already been created using
// the old version will not propagate the changes to those existing classes.
foam.CLASS({ name: 'Salary', extends: 'Float' });
foam.CLASS({ name: 'Emp', properties: [ { class: 'Salary', name: 'salary' } ] });

// Since Classes are not constructed until used, we create an instance to force
// Emp to be loaded (otherwise the refinement will appear to work):
log("Emp.salary before:", Emp.create().salary);
foam.CLASS({ refines: 'Salary', properties: [ { name: 'value', value: 30000 } ]});
log("Emp.salary refined:", Emp.create().salary);


##  Refine Property
Refine foam.core.Property Class
--
// Property has special support for refinement or existing Property instances
foam.CLASS({ name: 'Emp', properties: [ { class: 'Float', name: 'salary' } ] });
Emp.create();
foam.CLASS({ refines: 'Float', properties: [ [ 'javaClass', 'Float' ] ]});
log(Emp.SALARY.javaClass);


##  Cannot Refine a SuperProperty Class
Currently unsupported and unlikely to be supported
--
foam.CLASS({ name: 'SuperClass', properties: [ 'p1' ]});
foam.CLASS({ name: 'SubClass', extends: 'SuperClass', properties: [ 'p1' ]});
log('Before: super: ', SuperClass.create().p1, 'sub: ', SubClass.create().p1);

foam.CLASS({ refines: 'SuperClass', properties: [ { name: 'p1', value: 42 } ]});
log('Refined: super: ', SuperClass.create().p1, 'sub: ', SubClass.create().p1);


##  Cannot Refine a DoubleSuperProperty Class
Currently unsupported and unlikely to be supported. Two inheritance levels.
--
foam.CLASS({ name: 'SuperClass', properties: [ 'p1' ]});
foam.CLASS({ name: 'MidClass', extends: 'SuperClass' });
foam.CLASS({ name: 'SubClass', extends: 'MidClass', properties: [ 'p1' ]});
log('Before: super: ', SuperClass.create().p1, 'mid: ', MidClass.create().p1, 'sub: ', SubClass.create().p1);

// MidClass will see the refinement since it does not redefine the p1 property, so it
// uses SuperClass' directly. SubClass keeps its own definition, and doesn't see the changes
// to SuperClass.p1
foam.CLASS({ refines: 'SuperClass', properties: [ { name: 'p1', value: 42 } ]});
log('Refined: super: ', SuperClass.create().p1, 'mid: ', MidClass.create().p1, 'sub: ', SubClass.create().p1);


##  Create Listeners
Listeners are pre-bound Methods, suitable for use as callbacks (DOM, or otherwise).
--
foam.CLASS({
  name: 'ListenerTest',
  properties: [ 'name' ],
  methods: [ function m1() {
    log('m1', this.name);
    return 'M1' + this.name;
  } ],
  listeners: [ function l1() {
    log('l1', this.name);
    return 'L1' + this.name; // listener return value is ignored by most callers
  } ]
});
var o = ListenerTest.create({ name: 'Steve' });


##  Test Listeners as methods
Listeners are pre-bound Methods, suitable for use as callbacks (DOM, or otherwise).
--
// When called as methods, the same as Methods.
o.m1();
o.l1();


##  Test Listener binding
Listeners remember their self, binding "this" automatically
--
// When called as functions, the method forgets its 'self' and doesn't work,
// but the listener works.
var m = o.m1;
var l = o.l1;
m()
l();


##  Test Merged and Framed validation
It's an error to make a listener both isMerged and isFramed
--
foam.CLASS({
  name: 'MergedAndFramedTest',
  listeners: [
    {
      name: 'l',
      isMerged: true,
      isFramed: true,
      code: function() { log('listener'); }
    }
  ]
});
MergedAndFramedTest.create();


##  Test isMerged
isMerged will merge multiple events
--
c() {
      // TODO: for all async, pass things for postTestCode in promise resolve
      // If a listener has isMerged: true, it will merge multiple
      // events received withing 'mergeDelay' milliseconds into
      // a single event. 'mergeDelay' is optional and defaults to
      // 16ms.
      var mergedCalls = 0;

      foam.CLASS({
        name: 'MergedListenerTest',
        listeners: [
          {
            name: 'notMerged',
            isMerged: false, // the default
            code: function() {
              log('not merged listener');
            }
          },
          {
            name: 'merged',
            isMerged: true,
            mergeDelay: 1, // 1ms
            code: function() {
              log('merged listener ' + mergedCalls);
              mergedCalls += 1;
            }
          }
        ]
      });

      var o = MergedListenerTest.create();
      o.merged(); o.notMerged();
      o.merged(); o.notMerged();
      o.merged(); o.notMerged();
      o.merged(); o.notMerged();
      o.merged(); o.notMerged();
      o.merged(); o.notMerged();
      o.merged(); o.notMerged();

      // stop this test after one frame
      return new Promise(function(res) {
        setTimeout(res, 16);
      });


##  Framed Listener Test
isFramed will merge multiple events within an animation frame
--
c() {
      // If a listener has isFramed: true, it will merge multiple
      // events received withing one animation frame to a single
      // event delivered at the next animationFrame.
      var framedCalls = 0;
      foam.CLASS({
        name: 'FramedListenerTest',
        listeners: [
          {
            name: 'framed',
            isFramed: true,
            code: function() {
              log('framed listener ' + framedCalls);
              framedCalls += 1;
            }
          }
        ]
      });
      var o = FramedListenerTest.create();
      o.framed();
      o.framed();
      o.framed();
      o.framed();

      // delay for more than one frame to ensure the listener runs
      return new Promise(function(res) {
        setTimeout(res, 32);
      });


##  Listener delayed
Decorate a listener with delayed() to delay the execution without merging
--
c() {
      // You can decorate a listener with delayed() to delay the
      // execution of the listener. Unlike merged(), which also delays
      // results, delayed() does not merge results.
      var callOrder = '';
      var l1 = foam.__context__.delayed(function() {
        log('l1');
        callOrder += 'l1';
      }, 10);
      var l2 = foam.__context__.delayed(function() {
        log('l2');
        callOrder += 'l2';
      }, 5);
      l1();
      l2();
      l1();
      l2();

      // delay to ensure the listener runs
      return new Promise(function(res) {
        setTimeout(res, 16);
      });



##  Listener async
async(l) is the same as delayed(l, 0)
--
var callOrder = '';
var d1 = foam.__context__.async(function() {
  log('d1');
  callOrder += 'd1';
});
var d2 = function() {
  log('d2');
  callOrder += 'd2';
};
d1();
d2();
d1();
d2();

// delay to ensure the listener runs
return new Promise(function(res) {
  setTimeout(res, 16);
});


##  Listener SUPER
Listeners, like Methods, have SUPER support.
--
var alarms = '';
foam.CLASS({
  name: 'Alarm',
  listeners: [
    function alarm() { alarms += 'alarm!'; }
  ]
});
foam.CLASS({
  name: 'LongAlarm',
  extends: 'Alarm',
  listeners: [
    function alarm() {
      alarms += 'LongAlarm: ';
      this.SUPER(); this.SUPER(); this.SUPER();
    }
  ]
});
LongAlarm.create().alarm();
log(alarms);


##  Test Actions
Actions are methods which have extra information for GUIs
--
// Actions are methods which have extra information to make it easier
// to call them from GUIs. Extra information includes things like:
// a label, speech label, functions to determine if the action is currently
// available and enabled, user help text, etc.
var longCalls = 0;
foam.CLASS({
  name: 'ActionTest',
  properties: [ 'enabled', 'available' ],
  actions: [
    function shortForm() { log('short action!'); },
    {
      name: 'longForm',
      isAvailable: function() { return this.available; },
      isEnabled: function() { return this.enabled; },
      code: function() {
        log('long action!');
        longCalls += 1;
      }
    }
  ]
});
var o = ActionTest.create();
o.shortForm();

o.longForm(); // Won't be called because is not enabled or available yet
o.enabled = true;
o.longForm(); // Won't be called because is not available yet
o.available = true;
o.longForm(); // Finally able to be called


##  Interface inheritance
Interfaces copy Axioms from another class
--
// In addition to class-inheritance, FOAM also supports
// interfaces, which are a form of multiple-inheritance which
// copy Axioms from another model.
foam.CLASS({
  name: 'SampleI',
  properties: [ 't1', 't2', 't3' ],
  methods: [
    function tfoo() { log('tfoo'); },
    function tbar() { log('tbar'); }
  ]
});
foam.CLASS({
  name: 'ImplementsTest',
  implements: ['SampleI'],
  properties: [ 'p1', 'p2', 'p3' ],
  methods: [
    function foo() { log('foo'); },
    function bar() { log('bar'); }
  ]
});
var tt = ImplementsTest.create({p1:1, t1:2});
tt.tfoo(); // From SampleI
tt.foo();
log("Properties p1:", tt.p1, "t1:", tt.t1);


##  Interface multiple inheritance
Implements allows multiple inheritance, unlike extends
--
// Unlike regular inheritance with extends:, classes
// can implement: from multiple sources. However,
// implements only takes axioms from the class you reference,
// not anything it extends or implements.
foam.CLASS({
  name: 'Sample2I',
  properties: [ 'tb1', 'tb2', 'tb3' ],
  methods: [
    function tbfoo() { log('ffoo'); },
    function tbbar() { log('tbar'); }
  ]
});
foam.CLASS({
  name: 'ImplementsTest2',
  implements: ['SampleI', 'Sample2I']
});

log("ImplementsTest2 properties:",
  ImplementsTest2.getAxiomsByClass(foam.core.Property));


##  Property Inheritance
Properties in subclasses inherit from the parent's Properties
--
// FOAM also has Property-Inheritance.
// Test that a sub-class Property inherits its parent Property's class
foam.CLASS({
  name: 'PropertyInheritA',
  properties: [ {class: 'Boolean', name: 'sameName'} ]
});
foam.CLASS({
  name: 'PropertyInheritB',
  extends: 'PropertyInheritA',
  properties: [ 'sameName' ]
});
log(PropertyInheritA.SAME_NAME.cls_.id, PropertyInheritB.SAME_NAME.cls_.id);


##  Inner Classes
Inner classes are defined inside another class, not directly available in the global namespace.
--
// Classes can have inner-Classes.
var results = '';
foam.CLASS({
  name: 'InnerClassTest',
  classes: [
    { name: 'InnerClass1', properties: ['a', 'b'] },
    { name: 'InnerClass2', properties: ['x', 'y'] }
  ],
  methods: [
    function init() {
      // access from within the outer class
      var ic1 = this.InnerClass1.create({a:1, b:2});
      var ic2 = this.InnerClass2.create({x:5, y:10});
      results += ic1.a + ", " + ic1.b + ", " + ic2.x + ", " + ic2.y;
    }
  ]
});
InnerClassTest.create();
log(results);


##  Inner Class access
Inner classes are only accessible through their outer class
--
log("Access through outer:", InnerClassTest.InnerClass1.name);

// Inner-classes do not appear in the global namespace
log("Available globally?", !! globalThis.InnerClass1);


##  Inner Enums
Similar to Inner-classes, there's also Inner-enums
--
var result = '';
foam.CLASS({
  name: 'InnerEnumTest',
  enums: [
    { name: 'InnerEnum', values: [
    { name: 'OPEN',   label: 'Open'   },
    { name: 'CLOSED', label: 'Closed' }
    ] }
  ],
  methods: [
    function init() {
      // access from within the outer class
      result += this.InnerEnum.OPEN + " / " + this.InnerEnum.CLOSED;
    }
  ]
});
InnerEnumTest.create();
log(result);


##  Inner Enum access
Inner-enums can only be accessed through the outer-class
--
log("Access through outer:", InnerEnumTest.InnerEnum.name);

// Inner-enums do not appear in the global namespace
log("Available globally?", !! globalThis.InnerEnum);


##  Pub Sub
Objects can publish events and subscribe to other objects
--
foam.CLASS({
  name: 'PubSubTest'
});
var o = PubSubTest.create();


##  Subscribing
Objects can publish events and subscribe to other objects
--
// Objects support pub() for publishing events,
// and sub() for subscribing to published events.
var globalCalls = 0;
var alarmCalls = 0;
var globalResult = '';
// Install a listener that listens to all events
// Listeners are called with a subscription object and the given
//   arguments from pub().
o.sub(function() {
  log('  global listener: ', [].join.call(arguments, ' '));
  globalCalls += 1;
  globalResult += ' a' + arguments.length;
});
// This listener will only fire if the first argument matches 'alarm'
o.sub('alarm', function() {
  log('  alarm: ', [].join.call(arguments, ' '));
  alarmCalls += 1;
});
log("Pub alarm:");
o.pub('alarm', 'on');
log("Pub lifecycle:");
o.pub('lifecycle', 'loaded');


##  Publish arguments
Any number of arguments can be published
--
// Test publishing with many args
log("Pub many arguments:");
o.pub(1);
o.pub(1,2);
o.pub(1,2,3);
o.pub(1,2,3,4);
o.pub(1,2,3,4,5);
o.pub(1,2,3,4,5,6);
o.pub(1,2,3,4,5,6,7);
o.pub(1,2,3,4,5,6,7,8);
o.pub(1,2,3,4,5,6,7,8,9);
o.pub(1,2,3,4,5,6,7,8,9,10);
o.pub(1,2,3,4,5,6,7,8,9,10,11);
log(globalResult);


##  Topics
A Class can declare Topics that it publishes events for
--
foam.CLASS({
  name: 'TopicTest',
  topics: [ 'alarm' ]
});
var o = TopicTest.create();
var normalCalls = 0;
var topicCalls = 0;

o.sub('alarm', function(_, __, state) {
  log('alarm: ', state);
  normalCalls += 1;
});
// The next line uses the Topic and is slightly shorter than the equivalent above.
o.alarm.sub(function(_, __, state) {
  log('alarm (topic): ', state);
  topicCalls += 1;
});
o.alarm.pub('on');
o.pub('alarm', 'off');


##  propertyChange
Objects implicitly pub events on the propertyChange topic when property values change
--
foam.CLASS({
  name: 'PropertyChangeTest',
  properties: [ 'a', 'b' ]
});
o = PropertyChangeTest.create();
// propertyChange event listeners are called with:
//   sub  - the subscription object, which can be detach()ed to end
//            the subscription
//   p    - the string 'propertyChange'
//   name - the name of the changed property
//   dyn  - a dynamic access object to .get() the current value and
//            getPrev() the pre-change value

var anyChangeCalls = 0;
var propAChangeCalls = 0;
// Listen for all propertyChange events:
o.propertyChange.sub(function(sub, p, name, dyn) {
  log('propertyChange: ', p, name, dyn.getPrev(), dyn.get());
  anyChangeCalls += 1;
});

// Listen for only changes to the 'a' Property:
o.propertyChange.sub('a', function(sub, p, name, dyn) {
  log('propertyChange.a: ', p, name, dyn.getPrev(), dyn.get());
  propAChangeCalls += 1;
});

o.a = 42;
o.b = 'bar';
o.a++;


##  Unsubscribe from subscriber
1. Call .detach() on the Detachable that sub() returns
--

var calls = 0;
var l = function(sub, name) {
  log('Event:', name);
  calls += 1;
};

var sub = o.sub(l);
o.pub('fire');
sub.detach();
o.pub("fire again, but nobody's listenering");


##  Unsubscribe from listener
2. Detach the subscription, which is supplied to the listener
--
var calls = 0;
var once = function(sub, name) {
  log('Event:', name);
  calls += 1;
  // stop listening
  sub.detach();
};

o.sub(once);
o.pub('fire');
o.pub("fire again, but nobody's listening");


##  Unsubscribe with oneTime helper
3. If you only want to receive the first event, use foam.events.oneTime()
--
// If you only want to receive the first event, decorate your
// listener with foam.events.oneTime() and it will cancel the subscription
// when it receives the first event.
o.sub(foam.events.oneTime(function() {
  log.apply(log, arguments);
}));

o.pub('fire');
o.pub("fire again, but nobody's listenering");


##  Slot get
Slots are like Object-Oriented pointers
--
// A property's slot is accessed as 'name'$.
// get() is used to dereference the value of a slot
var p = Person.create({ name: 'Bob' });
var dyn = p.name$;
log("Person name:", dyn.get());


##  Slot set
set() is used to set a Slot's value
--
dyn.set('John'); // sets p.name implicitly
log("Name after set:", p.name, "get():", dyn.get());


##  Slot get with slot method
Calling obj.slot('name') is the same as obj.name$
--
var p = Person.create({name: 'Bob'});

var dyn = p.slot('name'); // same as p.name$
log("slot value:", dyn.get());

dyn.set('John');
log("after set:", dyn.get());


##  Slot nesting
Slots can be nested with dot() to bind to a sub-property of a property value
--
// Nested slots
foam.CLASS({ name: 'Holder', properties: [ 'data' ] });
var p1 = Person.create({name: 'John'});
var p2 = Person.create({name: 'Paul'});
var h = Holder.create({data: p1});
// Bind to the 'name' of whatever h.data will be, even if it changes
var s = h.data$.dot('name');

// Note that this listener is called when we swap p2 for p1, since
//  p2.name is not the same as p1.name.
var changes = "";
s.sub(function() {
  log('    h.data.name change: ', h.data.name);
  changes += h.data.name + " ";
});

log('Set to p1:');

log("  Initial s:", s.get());

s.set('George');
log("  After setting s, p1.name:", p1.name);

p1.name = 'Ringo';
log("  After setting p1.name, s:", s.get());

log('Setting to p2, which has a different name:');

h.data = p2;
log("  Initial s:", s.get());

s.set('George');
log("  After setting s, p2.name:", p2.name);

p2.name = 'Ringo';
log("  After setting p2.name, s:", s.get());


##  Subscription nesting
Subscribe using valueSub() of the slot, automatically resubscribed as the value changes
--
// Subscribe to the value of the slot data$, removing the
// subscription and resubscribing to the new value of data$
// if it changes.
foam.CLASS({ name: 'Holder', properties: [ 'data' ] });
var p1 = Person.create({name: 'John'});
var p2 = Person.create({name: 'Paul'});
var h = Holder.create({data: p1});
var changes = "";
h.data$.valueSub(function(e, topic, name, dyn) {
  log('sub change: ', e.src.name, topic, name);
  changes += topic + ':' + (dyn && dyn.get()) + ' ';
});

p1.name = 'Peter';
p2.name = 'Mary';
h.data = p2;
p1.name = 'James';
p2.name = 'Ringo';
p2.pub('test','event');


##  Data Binding two way
Assiging one slot to another binds their values
--
// Two-Way Data-Binding
// Slots can be assigned, causing two values to be
// bound to the same value.
var p1 = Person.create(), p2 = Person.create();

p1.name$ = p2.name$;
p1.name = 'John'; // also sets p2.name
log("Assigned first:", p1.name, p2.name);

p2.name = 'Steve'; // also sets p1.name
log("Assigned second: ", p1.name, p2.name);


##  Data Binding linkFrom
Another way to link two Slots is to call .linkFrom() on one of them
--
var p1 = Person.create({ name: 'p1' });
var p2 = Person.create({ name: 'p2' });
var d = p1.name$.linkFrom(p2.name$);
p1.name = 'John';
log("Assigned first:", p1.name, p2.name);


##  Data Binding linkFrom unbind
linkFrom/To() returns a detachable that unbinds the slots
--
// But this style of link can be broken by calling .detach()
// on the object return from .linkFrom/To().
d.detach();
p2.name = 'Steve';
log("No longer bound:", p1.name, p2.name);


##  Data Binding linkTo
linkTo() is the same as linkFrom(), except that the initial value is taken from 'this' instead of the other object
--
// linkTo() is the same as linkFrom(), except that the initial value
// is taken from 'this' instead of the other object.
var p1 = Person.create({ name:'p1' }), p2 = Person.create({ name:'p2' });
var d = p1.name$.linkTo(p2.name$);
log("After linkTo:", p1.name, p2.name);
var name2 = p2.name;

p1.name = 'John';
log("Assigned first:", p1.name, p2.name);


##  Data Binding relateTo
Two values can be linked through relateTo
--
// Two values can be linked through a relationship,
// which provides functions to adapt between the two values.
foam.CLASS({
  name: 'Temperature',
  properties: [
    { class: 'Float', name: 'f' },
    { class: 'Float', name: 'c' }
  ],
  methods: [
    function init() {
      this.f$.relateTo(
        this.c$,
        function f2c(f) {
          log('f2c', f); return 5/9 * ( f - 32 );
        },
        function c2f(c) {
          log('c2f', c); return 9/5 * c + 32;
        }
      );
    }
  ]
});

var t = Temperature.create();
log("Initial     f:", t.f, " c:", t.c);
t.f = 100;
log("Set(f=100)  f:", t.f, " c:", t.c);
t.c = 100;
log("Set(c=100)  f:", t.f, " c:", t.c);


##  Data Binding one way
The .follow() method binds in one direction only
--
// Calling .linkFrom()/.linkTo() creates a two-way data-binding, meaning a change in either
// value is reflected in the other.  But FOAM supports one-way data-binding as well.
// To do this, use the .follow() method.
var p1 = Person.create({ name:'p1' }), p2 = Person.create({ name:'p2' });
var d = p1.name$.follow(p2.name$);

p2.name = 'Ringo'; // Will update p1 and p2
p2.name = 'Paul'; // Will update p1 and p2
log('Assigned p2:', p1.name, p2.name);
p1.name = 'George'; // Will only update p1
log('Assigned p1:', p1.name, p2.name);
d.detach();


##  Data Binding one way initialization
Follow copies the initial value of the followed slot
--
p1 = Person.create();
p2 = Person.create({name:'John'});
log("Initial:", p1.name, p2.name);

p1.name$.follow(p2.name$);
log("After follow:", p1.name, p2.name);


##  Data Binding one way mapFrom
One-Way Data-Binding, with Map function (mapFrom)
--
var p1 = Person.create(), p2 = Person.create();
var d = p1.name$.mapFrom(p2.name$, function(n) {
  return n + "es";
});

p2.name = 'Ringo'; // Will update p1 and p2
log('Assigned second:', p1.name, p2.name);
p1.name = 'George'; // Will only update p1
log('Assigned first:', p1.name, p2.name);
d.detach();


##  Data Binding one way mapTo
One-Way Data-Binding, with Map function (mapTo)
--
// The reverse of mapFrom(), mapTo() takes the value of this,
// mapping it and assigning to the target.
var p1 = Person.create(), p2 = Person.create();
var d = p2.name$.mapTo(p1.name$, function(n) {
  return 'One' + n;
});

p2.name = 'Ringo'; // Will update p1 and p2
log("Assigned second:", p1.name, p2.name);
p1.name = 'George'; // Will only update p1
log("Assigned first:", p1.name, p2.name);
d.detach();


##  Slot isDefined
Slots also let you check if the value is defined by calling isDefined()
--
// Calling obj.name$.isDefined() is equivalent to obj.hasOwnProperty('name');
foam.CLASS({name: 'IsDefinedTest', properties: [ { name: 'a', value: 42 } ]});
var o = IsDefinedTest.create();
var dv = o.a$;
log("Default value only, isDefined?", dv.isDefined());
dv.set(99);
log("Set to 99, isDefined?", dv.isDefined());


##  Slot clear
You can reset a Slot to its default value by calling .clear()
--
// Calling obj.name$.clear() is equivalent to obj.clearProperty('name');
dv.clear();
log("After clearing:", dv.get(), dv.isDefined());


##  ConstantSlot
ConstantSlot creates an immutable slot
--
var s = foam.core.ConstantSlot.create({ value: 42 });
log("Intial value:", s.get());
s.value = 66;
s.set(66);
log("After set to 66:", s.get());


##  SimpleSlot
SimpleSlot creates a mutable slot.
--
var s = foam.core.SimpleSlot.create({ value: 42 });
log("Intial value:", s.get());
s.value = 66;
s.set(66);
log("After set to 66:", s.get());


##  PromiseSlot
PromiseSlot provides a declarative way of creating a slot that should contain the value of a promise when it resolves.
--
var promise = new Promise(function(resolve, reject) {
  globalThis.setTimeout(function() {
    resolve(66);
  }, 3000);
}).then((value) => {
  log('Promise resolved!', new Date());
  log('Slot value:', value);
});
log('Promise created.', new Date());
var s = foam.core.PromiseSlot.create({
  value: 42,
  promise: promise
});
log("Intial value of the slot:", s.get());
globalThis.setTimeout(() => {
  log('Value 1 second later, at ' + new Date() + ':', s.get());
}, 1000);
return promise;


##  ArraySlot
ArraySlot provides a way to group several slots together so that when any of them update we can invalidate.
--
var promise = new Promise(function(resolve, reject) {
  globalThis.setTimeout(() => resolve('bar'), 3000);
});
var s1 = foam.core.SimpleSlot.create({ value: 42 });
var s2 = foam.core.PromiseSlot.create({ value: 'foo', promise: promise });
var arraySlot = foam.core.ArraySlot.create({ slots: [s1, s2] });
log('Initial value:', arraySlot.get());
arraySlot.sub((detachable, eventName, propName, slot) => {
  log('Value updated to:', arraySlot.get());
});
s1.set(66);
return promise;


##  ProxySlot
ProxySlot provides a way to flatten/join a slot of a slot into what appears to be a slot of the inner slot's value. It lets you abstract away the inner slot.Using ProxySlot in this way is similar to how Promises that return Promises are automatically flattened/joined for you. However, in the case of slots, you need to explicitly use ProxySlot if you want this joining behaviour, otherwise you'll simply have a slot whose value is a slot. In this regard, slots are more flexible than Promises because it is up to the programmer to decide whether they want flattening/joining behaviour or not.
--
var s1 = foam.core.SimpleSlot.create({ value: 'fname' });
foam.CLASS({ name: 'Person', properties: ['fname', 'lname'] });
var p = Person.create({ fname: 'John', lname: 'Smith' });
var slotOfSlot = s1.map((propName) => {
  return p.slot(propName).map((propValue) => propName + ' = ' + propValue);
});
var proxySlot = foam.core.ProxySlot.create({ delegate$: slotOfSlot });
log('Value:', proxySlot.get());
s1.set('lname');
log('Value:', proxySlot.get());


##  Expression Slots
ExpressionSlot creates a Slot from a list of Slots and a function to combine them
--
foam.CLASS({ name: 'Person', properties: ['fname', 'lname'] });
var p = Person.create({ fname: 'John', lname: 'Smith' });
// When fname or lname changes, the new values are fed into the function
// to produce a new value for ExpressionSlot e
var e = foam.core.ExpressionSlot.create({
  args: [ p.fname$, p.lname$ ],
  code: function(f, l) { return f + ' ' + l; }
});

log("Intial e:", e.get());
var calls = 0;
e.sub(function() {
  log("e changed:", e.get());
  calls += 1;
});
p.fname = 'Steve';
p.lname = 'Jones';
log("Final e:", e.get());


##  Expression Slot with object
ExpressionSlot can use an object to supply the source slots
--
foam.CLASS({ name: 'Person', properties: [ 'f', 'l' ] });
var p = Person.create({ f:'John', l: 'Smith' });
// function arguments 'f' and 'l' are treated as property names on obj
var e = foam.core.ExpressionSlot.create({
  obj: p,
  code: function(f, l) { return f + ' ' + l; }
});
log("Initial e:", e.get());
e.sub(function() {
  log("e changed:", e.get());
});
p.f = 'Steve';
p.l = 'Jones';
log("Final e:", e.get());


##  Expression Slot unbinding
Detach the ExpressionSlot to prevent further updates
--
calls = 0;
e.detach();
log("e detached, setting f and l again...");
p.f = 'Bob';
p.l = 'Roberts';
log("Updates since detach:", calls);


##  Property Expression Class
The same functionality of ExpressionSlot is built into Properties
--
// Properties have the 'expression' feature
foam.CLASS({
  name: 'Person',
  properties: [
    'fname',
    'lname',
    {
      name: 'name',
      expression: function(fname, lname) { return fname + ' ' + lname; }
    }
  ]
});
var p = Person.create({ fname: 'John', lname: 'Smith' });


##  Property Expressions
Expression properties are invalidated whenever of their listed source values change
--
// Expression properties are invalidated
// whenever of their listed source values change, but are only recalculated
// when their value is accessed.
p.describe();
p.sub(function(sub, propChg, name) {
  log("Event:", propChg, name);
});
p.fname = 'Steve';
log(p.fname, p.lname, '=', p.name);
p.lname = 'Jones';
log(p.fname, p.lname, '=', p.name);


##  Property Expression setting
Expression properties can also be explicitly set, disabling the dynamic expression
--
log(p.name, p.hasOwnProperty('name'));
p.name = 'Kevin Greer';
log(p.name, p.hasOwnProperty('name'));
p.fname = 'Sebastian';
log(p.fname, p.lname, ':', p.name);


##  Property Expression
Clearing a set expression property reverts it to expression mode
--
p.name = "Joe"
log("Set directly:", p.name, "hasOwnProperty(name)?", p.hasOwnProperty('name'));
p.clearProperty('name');
log("After clearing:", p.name, "hasOwnProperty(name)?", p.hasOwnProperty('name'));


##  Detachables
Detachables or functions can be registered to be called when an object is detached.
--
// Detachables are objects with a detach() method, such as FObjects
// and sub()-returned subscriptions.
var o = foam.core.FObject.create();
var o2 = foam.core.FObject.create();
var detachs = '';

// onDetach adds a function to be called when the object is detached
o.onDetach(function() {
  log('detach 1');
  detachs += '1 ';
});
o2.onDetach(function() {
  log('detach 2');
  detachs += '2 ';
});

// cause o2 to be detached when o is detached
o.onDetach(o2);
o.detach();


##  Detachables idempotent
It doesn't hurt to try and detach an object more than once
--
var o = foam.core.FObject.create();
o.detach();
o.detach();


##  Detachables unsubscribe

--
// If an Object is detached, it will unsubscribe from any
// subscriptions which subsequently try to deliver events.
var source = foam.core.FObject.create();
var calls = 0;
foam.CLASS({
  name: 'Sink',
  listeners: [
    function l() {
      calls += 1;
      log('ping:', calls);
    }
  ]
});
var sink = Sink.create();
source.sub('ping', sink.l);
source.pub('ping');
source.pub('pong'); // There is no subscriber to the topic 'pong'
source.pub('ping');

// Detaching object and unsubscribing all subscribers
source.detach();
source.pub('ping');


##  Model validation extends refines
Extends and refines are mutually-exclusive
--
foam.CLASS({
  name: 'EandRTest',
  extends: 'FObject',
  refines: 'Model'
});
EandRTest.model_.validate();


##  Model validation property name exists
Properties must have names
--
foam.CLASS({
  name: 'ValidationTest',
  properties: [
    { name: '' }
  ]
});
ValidationTest.model_.validate();


##  Action validation names
Actions must have a name
--
foam.CLASS({
  name: 'ActionNameValidation',
  actions: [
    { name: '', code: function() {} }
  ]
});
ActionNameValidation.model_.validate();


##  Action validation code
Actions must have code
--
foam.CLASS({
  name: 'ActionCodeValidation',
  actions: [
    { name: 'test' }
  ]
});
ActionCodeValidation.model_.validate();


##  Model validation property slot name
Properties names must not end with $
--
foam.CLASS({
  name: 'DollarValidationTest',
  properties: [
    { name: 'name$' }
  ]
});
DollarValidationTest.model_.validate();


##  Model validation property constants
Property constants must not conflict
--
foam.CLASS({
  name: 'ConstantConflictTest',
  properties: [ 'firstName', 'FirstName' ]
});
ConstantConflictTest.model_.validate();


##  Model validation property same name
Properties must not have the same name
--
foam.CLASS({
  name: 'AxiomConflict1',
  properties: [ 'sameName', 'sameName' ]
});
AxiomConflict1.model_.validate();


##  Model validation same method name
Methods must not have the same name
--
foam.CLASS({
  name: 'AxiomConflict2',
  methods: [ function sameName() {}, function sameName() {} ]
});
AxiomConflict2.model_.validate();


##  Axiom validation same name
Axioms must not have the same name
--
//
foam.CLASS({
  name: 'AxiomConflict3',
  properties: [ 'sameName' ],
  methods: [ function sameName() {} ]
});
AxiomConflict3.model_.validate();


##  Axiom validation sub property type
A Property cannot be changed to a non-Property
--
foam.CLASS({
  name: 'AxiomChangeSuper',
  properties: [ 'sameName' ] // property
});
foam.CLASS({
  name: 'AxiomChangeSub',
  extends: 'AxiomChangeSuper',
  methods: [ function sameName() {} ] // now it's a method? no!
});
AxiomChangeSub.model_.validate();


##  Axiom validation class change
Warn if an Axiom changes its class
--
foam.CLASS({
  name: 'AxiomChangeSuper2',
  methods: [ function sameName() {} ]
});
foam.CLASS({
  name: 'AxiomChangeSub2',
  extends: 'AxiomChangeSuper2',
  properties: [ 'sameName' ]
});
AxiomChangeSub2.model_.validate();


##  Property validation single accessor
Properties may only have one of factory, value, expression, or getter; one of setter or adapt+preset+postset
--
var setTo;
foam.CLASS({
  name: 'PropertyValidationTest',
  properties: [
    {
      name: 't1',
      setter: function() { setTo = 1; this.instance_.t1 = 1; },
      adapt: function(_,v) { return v + 1; },
      preSet: function(_,v) { return v + 1; },
      postSet: function(_,v) { setTo = v + 1; }
    },
    {
      name: 't2',
      getter: function() { return 42; },
      factory: function() { return 43; },
      expression: function() { return 44; },
      value: 45
    }
  ]
});
PropertyValidationTest.model_.validate();


##  Property required
Properties marked required must have values supplied to create()
--
// Required
foam.CLASS({
  name: 'ValidationTest',
  properties: [
    { name: 'test', required: true }
  ]
});

var o = ValidationTest.create({test: '42'});
o.validate();
log('-');
var o = ValidationTest.create();
o.validate();


##  Unknown Properties
Unknown Model and Property properties are detected
--
foam.CLASS({
  name: 'ValidationTest',
  unknown: 'foobar',
  properties: [
    { name: 'test', unknown: 'foobar' }
  ]
});
ValidationTest.model_.validate();


##  Context create sub context
Contexts can be explicitly created with foam.createSubContext()
--
// The second argument of createSubContext() is an optional name for the Context
var Y1 = foam.createSubContext({
  key: 'value',
  fn: function() {
    return 'here';
  }
}, 'SubContext');
log("Y1:", Y1.key, Y1.fn());


##  Context context sub context
Sub-Contexts can be created from other Contexts
--
var Y2 = Y1.createSubContext({ key: 'value2' });
log("Y2:", Y2.key, Y2.fn());


##  Context sub context describe
A Context's contents can be inspected with .describe()
--
Y1.describe();
Y2.describe();


##  Imports Test Class
Imports are pulled from the context when an instance is created
--
foam.CLASS({
  name: 'ImportsTest',
  imports: [ 'myLogger' ],
  methods: [ function foo() {
    this.myLogger('log foo from ImportTest');
  } ]
});


##  Import context values
Classes can import values from the Context so that they can be accessed from this
--
// First try the import with no 'myLogger' in its context
try {
  var o = ImportsTest.create(); // should fail here, on object creation
  log('test created');
  o.foo();
} catch(e) {
  log('Could not import "myLogger" since nobody provided it.');
}

var lastLogMsg = "";
// Provide a 'myLogger' on a context
var Y = foam.createSubContext({ myLogger: function(msg) {
  log('log:', msg);
  lastLogMsg = msg;
}});

Y.myLogger('test');
// Using 'requires' supplies the context automatically, but for this
// example we supply the context explicitly.
var o = ImportsTest.create(null, Y); // create with context Y
o.foo();


##  Imports optional
Optional imports, marked with a ?, don't warn if not found
--
foam.CLASS({
  name: 'OptionalImportsTest',
  imports: [ 'myLogger?' ],
  methods: [ function foo() {
    this.myLogger('log foo from ImportTest');
  } ]
});
try {
  var o = OptionalImportsTest.create();
  log('Test created ok');
  log('Trying to use missing import...');
  o.foo(); // should fail here, on import use
} catch(e) {
  log('As expected, could not import "myLogger" since nobody provided it.');
}


##  Export context values
Classes can export values for use by objects they create
--
var calls = 0;
foam.CLASS({
  name: 'ExportsTest',
  requires: [ 'ImportsTest' ],
  exports: [ 'myLogger' ],
  methods: [
    function init() {
      this.ImportsTest.create().foo();
    },
    function myLogger(msg) {
      // this function is exported, thus available to object we create
      // (like ImportsTest in our init)
      log('ExportsTest logger call:', msg);
      calls += 1;
    }
  ]
});
ExportsTest.create();


##  Packages
Classes can specify a package
--
foam.CLASS({
  package: 'com.acme',
  name: 'Test',
  methods: [ function foo() {
    log('Hello, I am foo() from com.acme.Test');
  } ]
});
com.acme.Test.create().foo();


##  Requires
Classes should requires: other Classes they need to use
--
// Classes can requires: other Classes to avoid having to reference them
// by their fully-qualified names. The creation context (and thus our
// exports) is also automatically provided.
foam.CLASS({
  name: 'RequiresTest',
  requires: ['com.acme.Test' ],
  methods: [ function foo() {
    this.Test.create().foo();
  } ]
});

log("When required:");
RequiresTest.create().foo();


##  Requires as
Requires can use as to alias required Classes
--
// Use 'as' to pick the name to use on 'this'. If a required
// class is named the same as one of your properties or methods,
// or two required classes have the same name, you may be forced
// to specify the name with 'as':
foam.CLASS({
  name: 'RequiresAliasTest',
  requires: ['com.acme.Test as NotTest' ],
  methods: [ function foo() {
    this.NotTest.create().foo();
  } ]
});

log("Required as NotTest:");
RequiresAliasTest.create().foo();


##  Primary Key
Classes can have a unique-id or primary-key
--
// By default, this is simply the field named 'id'.
foam.CLASS({
  name: 'Invoice',
  properties: [ 'id', 'desc', 'amount' ]
});
var o = Invoice.create({ id: 1, desc: 'Duct Cleaning', amount: 99.99 });
log(o.id);


##  Primary Key ids
Use the ids property to specify that the primary key be something other than id
--
// You can also use the 'ids' property to specify that
// the primary key be something other than 'id'.
// In this case, 'id' will become an psedo-property for
// accessing the real 'invoiceId' property.
foam.CLASS({
  name: 'Invoice2',
  ids: [ 'invoiceId' ],
  properties: [ 'invoiceId', 'desc', 'amount' ]
});
var o = Invoice2.create({ invoiceId: 23, desc: 'Duct Cleaning', amount: 99.99 });
log("Id:", o.id, "invoiceId:", o.invoiceId);


##  Primary Key multipart Class
Multi-part unique identifiers are also supported by setting ids
--
foam.CLASS({
  name: 'Invoice3',
  ids: [ 'customerId', 'invoiceId' ],
  properties: [ 'customerId', 'invoiceId', 'desc', 'amount' ]
});


##  Primary Key multipart
Multi-part unique identifiers are also supported by setting ids
--
var o = Invoice3.create({customerId: 1, invoiceId: 1, desc: 'Duct Cleaning', amount: 99.99});
log("initial           id:", o.id, "customerId:", o.customerId, "invoiceId:", o.invoiceId);
// setting id propagates the changes to the properties that make up the
// multipart id:
o.id = [2, 3];
log("after setting id, id:", o.id, "customerId:", o.customerId, "invoiceId:", o.invoiceId);


##  Primary Key multipart comparison
Multi-part ids are comparable
--
var results = '';
results += Invoice3.ID.compare(
  Invoice3.create({customerId: 1, invoiceId: 2}),
  Invoice3.create({customerId: 1, invoiceId: 1}));

results += ", " + Invoice3.ID.compare(
  Invoice3.create({customerId: 1, invoiceId: 1}),
  Invoice3.create({customerId: 1, invoiceId: 2}));

results += ", " + Invoice3.ID.compare(
  Invoice3.create({customerId: 1, invoiceId: 1}),
  Invoice3.create({customerId: 1, invoiceId: 1}));

results += ", " + Invoice3.ID.compare(
  Invoice3.create({customerId: 2, invoiceId: 1}),
  Invoice3.create({customerId: 1, invoiceId: 1}));

results += ", " + Invoice3.ID.compare(
  Invoice3.create({customerId: 1, invoiceId: 1}),
  Invoice3.create({customerId: 2, invoiceId: 1}));

log("Comparison results:", results);


##  Class Id
A Class' id is a combination of its package and name
--
log("Test class id:", com.acme.Test.id);


##  Custom Axioms
Specify arbitrary Axioms for a Class with axioms:
--
// In addition the the built-in Axiom types, you can also
// specify arbitrary Axioms with 'axioms:'.
// This example adds the 'Singleton' axiom to make a class
// implement the Singleton patter (ie. there can only be
// one instance)
foam.CLASS({
  name: 'AxiomTest',
  axioms: [ foam.pattern.Singleton.create() ],
  methods: [ function init() {
    log('Creating AxiomTest');
  } ]
});

AxiomTest.create();
AxiomTest.create();
log("Same instance?", AxiomTest.create() === AxiomTest.create());


##  Custom Axioms inherit
Gain the custom axioms of a Class you extend
--
//
foam.CLASS({
  name: 'AxiomSubTest',
  extends: 'AxiomTest',
  methods: [ function init() {
    log('Creating AxiomSubTest');
  } ]
});
AxiomSubTest.create();
AxiomSubTest.create();
log("sub is same instance?", AxiomSubTest.create() === AxiomSubTest.create());
log("sub same as super?", AxiomSubTest.create() === AxiomTest.create());


##  Multiton
Add the Multion axiom to implement the Multiton pattern
--
// Multitons create one shared instance per value, based on the given
// property.
foam.CLASS({
  name: 'Color',
  axioms: [ foam.pattern.Multiton.create({ property: 'color' }) ],
  properties: [ 'color' ],
  methods: [ function init() {
    log('Creating Color:', this.color);
  } ]
});

var red1 = Color.create({color: 'red'});
var red2 = Color.create({color: 'red'});
var blue = Color.create({color: 'blue'});

log('reds same?', red1 === red2);
log('red same as blue?', red1 === blue);


##  Object UID
All Objects have a unique identifier, accessible with the .$UID property
--
var a = {}, b = [], c = Person.create();
log(a.$UID, b.$UID, c.$UID);


##  Console log listener
foam.events.consoleLog() returns a convenient listener that logs
--
// foam.events.consoleLog
foam.CLASS({name: 'ConsoleLogTest'});
var o = ConsoleLogTest.create();
o.sub(foam.events.consoleLog());
o.pub();
o.pub('foo');
o.pub('foo','bar');


##  Function memoize1
foam.Function.memoize1() memoizes a one-argument function
--
// if called again with the same argument, the previously generated
// value will be returned rather than calling the function again.
var calls = 0;
var f = foam.Function.memoize1(function(x) {
  calls += 1;
  log('calculating ', x, "=>", x*x);
  return x*x;
});

log(f(2));
log(f(2));
log(f(4));
log("Total number of calls:", calls);


##  Function memoize1 one arg only
A call to memoize1'ed function with no arguments or too many arguments will trigger a failed assertion
--
f();
f(1, 2);


##  Function argsStr
foam.Function.argsStr() returns a function's arguments as a string
--
var f = function(a, b, fooBar) { };
var argsAsStr = foam.Function.argsStr(f);
log('Function args:', argsAsStr);


##  Function argNames
foam.Function.argNames() returns a function's arguments an an array
--
var f = function(a, b, fooBar) { };
var argsAsArray = foam.Function.argNames(f);
log('Function args array:', argsAsArray);


##  String constantize
foam.String.constantize converts strings from camelCase to CONSTANT_FORMAT
--
log('foo      =>', foam.String.constantize('foo'));
log('fooBar   =>', foam.String.constantize('fooBar'));
log('fooBar12 =>', foam.String.constantize('fooBar12'));


##  String capitalize
foam.String.capitalize capitalizes the first letter of a string
--
log(foam.String.capitalize('Abc def'));
log(foam.String.capitalize('abc def'));


##  String labelize
foam.String.labelize converts from camelCase to labels
--
log(foam.String.labelize('camelCase'));
log(foam.String.labelize('firstName'));
log(foam.String.labelize('someLongName'));


##  String pad
foam.String.pad() pads a string to the specified length
--
var s = foam.String.pad('foobar', 10);
log("padded  10:", '"' + s + '"', s.length);

// pad() is right justifying if given a negative number
var s = foam.String.pad('foobar', -10);
log("padded -10:", '"' + s + '"', s.length);


##  Template basics
Templates use a JSP syntax to insert properties and code
--
//
foam.CLASS({
  name: 'TemplateTest',
  properties: [
    'name'
  ],
  templates: [
    {
      name: 'hello',
      template: 'Hello, my name is <%= this.name %>.'
    }
  ]
});

var o = TemplateTest.create({ name: 'Adam' });
log(o.hello());


##  Template arguments
Templates can be declared to accept arguments
--
foam.CLASS({
  name: 'TemplateTest',
  properties: [
    'name'
  ],
  templates: [
    {
      name: 'greet',
      args: [
        'stranger'
      ],
      template: 'Hello <%= stranger %>, my name is <%= this.name %>.'
    }
  ]
});

var o = TemplateTest.create({ name: 'Adam' });
log(o.greet("Bob"));


##  Template nesting
Templates can be called from other templates. Include output as the first argument.
--
foam.CLASS({
  name: 'TemplateTest',
  properties: [ 'name' ],
  templates: [
    {
      name: 'greeter',
      args: [ 'stranger' ],
      template: 'Hello <%= stranger %>'
    },
    {
      name: 'greet',
      args: ['stranger'],
      // 'output' is an implicit argument you must pass when calling one template
      // from another.
      template: '<% this.greeter(output, stranger); %>, my name is <%= this.name %>'
    }
  ]
});

var o = TemplateTest.create({ name: 'Adam' });
log(o.greet("Alice"));


##  Template code
Template can use raw JS code for loops and control structures
--
foam.CLASS({
  name: 'TemplateTest',
  properties: [ 'name' ],
  templates: [
    {
      name: 'complexTemplate',
      template: 'Use raw JS code for loops and control structures' +
        '<% for ( var i = 0 ; i < 10; i++ ) { %>\n' +
        'i is: "<%= i %>" <% if ( i % 2 == 0 ) { %> which is even!<% } '+
        '} %>' +
        '\n\n' +
        'Use percent signs to shortcut access to local properties\n' +
        'For instance, my name is %%name\n'
    }
  ]
});

log(TemplateTest.create({ name: 'Adam' }).complexTemplate());


##  Template mutliline
Multi-line templates can be defined as function comments
--
      foam.CLASS({
        name: 'MultiLineTemplateTest',
        properties: [ 'name' ],
        templates: [
          {
            name: 'complexTemplate',
            template: `
Use raw JS code for loops and control structures
<% for ( var i = 0 ; i < 10; i++ ) { %>
i is: "<%= i %>" <% if ( i % 2 == 0 ) { %> which is even!<% }
} %>
Use percent signs to shortcut access to local properties
For instance, my name is %%name
            `
          }
        ]
      });
      log(MultiLineTemplateTest.create({ name: 'Adam' }).complexTemplate());


##  Create JSON Class
Conversion to and from JSON is supported
--
foam.CLASS({
  name: 'JSONTest',
  properties: [
    { name: 'name', shortName: 'n' },
    { class: 'Int', name: 'age', shortName: 'a' },
    { class: 'StringArray', name: 'children', shortName: 'cs' },
    { name: 'name That Needs Quoting' },
    { name: 'undefined' },
    { name: 'defined' },
    { class: 'String', name: 'undefinedString' },
    { class: 'String', name: 'definedString' },
    { class: 'String', name: 'defaultString', value: 'default' },
    { class: 'Int', name: 'undefinedInt' },
    { class: 'Int', name: 'definedInt' },
    { class: 'Int', name: 'defaultInt', value: 3 },
    { class: 'Float', name: 'undefinedFloat' },
    { class: 'Float', name: 'definedFloat' },
    { class: 'Float', name: 'defaultFloat', value: 3.14 },
    { class: 'Boolean', name: 'undefinedBoolean' },
    { class: 'Boolean', name: 'trueBoolean' },
    { class: 'Boolean', name: 'falseBoolean' },
    { class: 'Boolean', name: 'defaultBoolean', value: true },
    { class: 'Function', name: 'undefinedFunction' },
    { class: 'Function', name: 'definedFunction' },
    { name: 'undefinedFObject' },
    { name: 'definedFObject' },
    { name: 'transient', transient: true },
    { name: 'networkTransient', networkTransient: true },
    { name: 'storageTransient', storageTransient: true },
//    { name: '' },
  ]
});


##  JSON parse
Use foam.json.parse(someJSONobject) to convert to an FObject
--
var o = foam.json.parse({
  class: 'JSONTest',
  name: 'John',
  age: 42,
  children: ['Peter', 'Paul']});
o.describe();


##  JSON output
Use foam.json.stringify(fobject) to serialize an FObject to a JSON string
--
o = JSONTest.create({
  name: 'John',
  age: 42,
  children: ['Peter', 'Paul'],
  "name That Needs Quoting": 42,
  defined: 'value',
  definedString: 'stringValue',
  definedInt: 42,
  defaultInt: 3,
  definedFloat: 42.42,
  defaultFloat: 3.14,
  trueBoolean: true,
  falseBoolean: false,
  defaultBoolean: true,
  definedFunction: function plus(a, b) { return a + b; },
  definedFObject: JSONTest.create({
    name: 'Janet',
    age: 32,
    children: [ 'Kim', 'Kathy' ]
  }),
  transient: 'transient value',
  networkTransient: 'network transient value',
  storageTransient: 'storage transient value'
});
// Default JSON formatting
log(foam.json.stringify(o));



##  JSON output modes
Different outputters support suppressing properties, transients, and other options
--
// Outputters have different defaults for formatting, which properties
// to output, etc. You can clone one and change these settings on the
// outputter to customize your JSON output.

log('\nConvert to a JSON object (instead of a String):');
log(foam.json.stringify(JSONTest.create(foam.json.objectify(o))));

log('\nAs a method on Objects:');
log(o.stringify());

log('\nPretty-printed output:');
log(foam.json.Pretty.stringify(o));

log('\nDisable class name output by cloning your own outputter:');
log(foam.json.Pretty.clone().copyFrom({ outputClassNames: false }).stringify(o));

log('\nStrict output:');
log(foam.json.Strict.stringify(o));

log('\nStrict-but-still-readable output:');
log(foam.json.PrettyStrict.stringify(o));

log('\nCompact output:');
log(foam.json.Compact.stringify(o));

log('\nShort-name (very compact) output:');
log(foam.json.Short.stringify(o));

log('\nNetwork (network-transient properties omitted) output:');
log(foam.json.Network.stringify(o));

log('\nStorage (storage-transient properties omitted) output:');
log(foam.json.Storage.stringify(o));


##  Graphics Support
CViews enable canvas rendering
--
foam.CLASS({
  name: 'GraphicsDemo',
  extends: 'foam.graphics.CView',
  requires: [
    'foam.graphics.Arc',
    'foam.graphics.Box',
    'foam.graphics.Circle',
    'foam.graphics.CView',
    'foam.graphics.Gradient'
  ],
  properties: [
    [ 'width', 500 ],
    [ 'height', 500 ],
    {
      name: 'children',
      factory: function() {
        var objects = [
          this.Arc.create({
            start: 0,
            end: 1.5*Math.PI,
            radius: 40
          }),
          this.Circle.create({
            color: this.Gradient.create({
              radial: true,
              x0: 0, y0: 0, r0: 10,
              x1: 0, y1: 0, r1: 100,
              colors: [
                [0, 'green'],
                [0.4, 'blue'],
                [0.6, 'red'],
                [1, 'white']
              ]
            }),
            border: '',
            radius: 100,
            x: 300,
            y: 300
          }),
          this.Box.create({
            color: this.Gradient.create({
              radial: false,
              x0: 0, y0: 0,
              x1: 100, y1: 100,
              colors: [
                [0, 'black'],
                [1, 'white']
              ]
            }),
            width: 100,
            height: 100,
            originX: 50,
            originY: 50,
            x: 100,
            y: 400,
            children: [
              this.Circle.create({
                color: 'red',
                x: 30,
                y: 30,
                radius: 10
              }),
              this.Circle.create({
                color: 'red',
                x: 70,
                y: 30,
                radius: 10
              }),
              this.Circle.create({
                color: 'red',
                x: 30,
                y: 70,
                radius: 10
              }),
              this.Circle.create({
                color: 'red',
                x: 70,
                y: 70,
                radius: 10
              }),
              this.Circle.create({
                color: 'red',
                x: 50,
                y: 50,
                radius: 10
              })
            ]
          })
        ];
        return objects;
      }
    },
    {
      name: 'counter',
      value: 0
    }
  ],
  listeners: [
    {
      name: 'step',
      isFramed: true,
      code: function() {
        this.counter += 0.01
        this.children[0].rotation += 0.1;
        this.children[0].x = 150 + 50 * Math.cos(this.counter);
        this.children[0].y = 150 + 50 * Math.sin(this.counter);
        this.children[1].skewX = Math.sin(this.counter);
        this.children[2].scaleX = 0.5 + 0.5 * Math.abs(Math.cos(this.counter));
        this.children[2].scaleY = 0.5 + 0.5 * Math.abs(Math.sin(this.counter));
        this.children[2].rotation += 0.01;
        this.step();
        this.invalidated.pub();
      }
    }
  ]
});
var g = GraphicsDemo.create();
add(g);
//g.write();
//g.step();
